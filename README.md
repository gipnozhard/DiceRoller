# DiceRoller

## 1. Прежде чем вы начнете

Для кодовых лабораторий в этом пути вы будете создавать приложение Dice Roller для Android. Когда пользователь "бросает кости", будет сгенерирован случайный результат. В результате учитывается количество сторон кубика. Например, из 6-стороннего кубика можно выпадать только значения от 1 до 6.

Так будет выглядеть конечное приложение.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/33bf7dcb-c3db-4cf7-843a-d292659c0cfc)

Чтобы помочь вам сосредоточиться на новых концепциях программирования для этого приложения, вы будете использовать браузерный инструмент программирования Kotlin для создания основных функциональных возможностей приложения. Программа выведет ваши результаты на консоль. Позже вы будете реализовывать пользовательский интерфейс в Android Studio.

В этой первой кодовой лаборатории вы создадите программу Kotlin, которая имитирует бросание игральных костей и выдает случайное число, точно так же, как это делают игральные кости.

### Предварительные требования:

 * Как открывать, редактировать и запускать код в https://developer.android.com/training/kotlinplayground

 * Создайте и запустите программу Kotlin, которая использует переменные и функции и выводит результат на консоль.

 * Форматируйте числа в тексте, используя строковый шаблон с ${variable} обозначением.

### Чему вы научитесь:

 - Как программно генерировать случайные числа для имитации бросков костей.

 - Как структурировать свой код, создав Dice класс с переменной и методом.

 - Как создать экземпляр объекта класса, изменить его переменные и вызвать его методы.

### Что вы будете создавать:

 * Программа Kotlin в браузерном инструменте программирования Kotlin, которая может выполнять случайный бросок кости.

### Что вам нужно:

 * Компьютер с подключением к Интернету

## 2. Набирайте случайные числа

В играх часто присутствует элемент случайности. Вы можете получить случайный приз или продвинуться на случайное количество шагов по игровому полю. В повседневной жизни вы можете использовать случайные числа и буквы для создания безопасных паролей!

Вместо того, чтобы бросать реальные кости, вы можете написать программу, которая имитирует бросание костей для вас. Каждый раз, когда вы бросаете кости, результатом может быть любое число в диапазоне возможных значений. К счастью, вам не нужно создавать свой собственный генератор случайных чисел для такой программы. Большинство языков программирования, включая Kotlin, имеют встроенный способ генерации случайных чисел. В этой задаче вы будете использовать код Kotlin для генерации случайного числа.

### Настройте свой начальный код

 1. Откройте веб-сайт в своем браузере https://developer.android.com/training/kotlinplayground.

 2. Удалите весь существующий код в редакторе кода и замените его приведенным ниже кодом. Это main() функция, с которой вы работали в более ранних codelabs.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/5294b418-4b44-4380-9587-d1b81075d8c8)

### Используйте функцию random

Чтобы бросить кости, вам нужен способ представления всех допустимых значений бросков костей. Для обычных 6-гранных костей допустимыми бросками костей являются: 1, 2, 3, 4, 5, и 6.

Ранее вы узнали, что существуют такие типы данных, как Int для целых чисел и String для текста. IntRange - это другой тип данных, и он представляет диапазон целых чисел от начальной точки до конечной. IntRange - это подходящий тип данных для представления возможных значений, которые может дать бросок кости.

 1. Внутри вашей main() функции определите переменную как val вызываемую diceRange. Присвоите ему значение IntRange от 1 до 6, представляющее диапазон целых чисел, которые может бросить шестигранный кубик.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/bf3f5f14-0b13-44b4-81df-6bb69d332773)

Вы можете сказать, что 1..6 это диапазон Kotlin, потому что у него есть начальный номер, две точки, за которыми следует конечный номер (без пробелов между ними). Другими примерами диапазонов целых чисел являются 2..5 для чисел от 2 до 5 и 100..200 для чисел от 100 до 200.

----------------------------------------------------------------

Совет: Обратите внимание, что в этом определении не указано IntRange, точно так же, как вам не нужно было указывать Int or String при создании переменной для целого числа или строки. В большинстве случаев система может определить, какой тип данных вы собираетесь использовать.

Например, система интерпретирует это:

 val diceRange = 1..6

поскольку это:

 val diceRange: IntRange = 1..6

-----------------------------------------------------------------

Аналогично тому, как вызов println() сообщает системе напечатать заданный текст, вы можете использовать вызываемую функцию random() для генерации и возврата случайного числа для вас в заданном диапазоне. Как и раньше, вы можете сохранить результат в переменной.

 2. Внутри main() определите переменную как val вызываемую randomNumber.
 
 3. Сделайте так, чтобы у randomNumber результата вызова было значение random() в diceRange диапазоне, как показано ниже.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/9c1c1211-91ec-4f4e-ac28-b6c8f6cf7328)

Обратите внимание, что вы вызываете random() on diceRange, используя точку между переменной и вызовом функции. Вы можете прочитать это как "генерация случайного числа из diceRange". Затем результат сохраняется в randomNumber переменной.

 4. Чтобы увидеть случайно сгенерированное число, используйте нотацию форматирования строки (также называемую "шаблон строки") ${randomNumber} для его печати, как показано ниже.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/79142c2a-7954-452a-a86b-c42c105a2658)

Ваш готовый код должен выглядеть следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/31221225-2d86-4994-8f6d-44708bacc203)

 5. Запустите свой код несколько раз. Каждый раз вы должны видеть вывод, как показано ниже, с разными случайными числами


![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/d9968ee2-a915-4b5b-8ab7-5244f74de3ec)

---------------------------------------------------------------

 Советы по диапазонам:

 * Диапазоны могут составлять любые целые числа. Допустимыми диапазонами являются следующие: 3..46, 0..270, -6..+6, -10..-4.

 * Вы можете вызывать функции непосредственно в диапазоне, например: (1..6).random().

----------------------------------------------------------------

## 3. Создайте класс Dice

Когда вы бросаете кости, они становятся реальными объектами в ваших руках. Хотя код, который вы только что написали, работает отлично, трудно представить, что речь идет о реальных кубиках. Организация программы так, чтобы она была больше похожа на то, что она представляет, облегчает ее понимание. Итак, было бы здорово иметь программные кости, которые вы можете бросать!

Все кубики работают по существу одинаково. Они обладают одинаковыми свойствами, такими как стороны, и у них одинаковое поведение, например, их можно бросать. В Kotlin вы можете создать программный чертеж кости, в котором указано, что кости имеют стороны и могут выпадать случайным числом. Этот чертеж называется классом.

Затем на основе этого класса вы можете создавать реальные объекты dice, называемые экземплярами объектов. Например, вы можете создать 12-сторонний кубик или 4-сторонний кубик.

--------------------------------------------------------------

Совет: Класс подобен тому, как чертежные планы архитектора - это не сам дом; это инструкции о том, как построить дом. Дом - это реальная вещь, или экземпляр объекта, созданный в соответствии с планом.

---------------------------------------------------------------

---------------------------------------------------------------

Примечание: Организация всего, что связано с dice, в класс называется инкапсуляцией. Инкапсуляция - это большое причудливое слово, но все, что оно означает, это то, что вы можете поместить функциональность, которая логически связана, в одно место.

---------------------------------------------------------------
 
### Определите класс Dice

На следующих шагах вы определите новый класс с именем Dice для представления игральной кости, которую можно бросать.

 1. Чтобы начать заново, очистите код в main() функции, чтобы в конечном итоге получить код, как показано ниже.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/cfc944a7-8d67-4d96-94fd-8387f3782b04)

 2. Под этой main() функцией добавьте пустую строку, а затем добавьте код для создания Dice класса. Как показано ниже, начните с ключевого слова class, за которым следует название класса, а затем открывающая и закрывающая фигурные скобки. Оставьте пробел между фигурными скобками, чтобы поместить ваш код для класса.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/314065d9-aeb2-4395-94d5-c5bdf9a56a1d)

--------------------------------------------------------------

Примечание:

 * Аналогично использованию fun ключевого слова в Kotlin для создания новой функции, используйте class ключевое слово для создания нового класса.

 * Вы можете выбрать любое имя для class, но полезно, если имя указывает, что представляет класс. По соглашению, имя класса записывается в верхнем регистре Camel (также называемом оболочкой Pascal). Например: Car, ParkingMeter и CustomerRecord все допустимые имена классов, и вы можете догадаться, что они представляют.

---------------------------------------------------------------

Внутри определения класса вы можете указать одно или несколько свойств для класса с помощью переменных. Реальные кости могут иметь несколько сторон, цвет или вес. В этой задаче вы сосредоточитесь на свойстве количества сторон кубика.

 3. Внутри Dice класса добавьте var called sides для обозначения количества сторон, которые будут иметь ваши кости. Установите sides значение 6.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/816989ce-3b7f-4631-b352-0bed52a279e9)

Вот и все. Теперь у вас есть очень простой класс, представляющий dice.

### Создайте экземпляр класса Dice

С помощью этого Dice класса у вас есть общее представление о том, что такое dice. Чтобы иметь реальную dice в вашей программе, вам необходимо создать Dice экземпляр объекта. (И если бы вам понадобилось иметь три кубика, вы бы создали три экземпляра объекта.)

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/aa9f2b43-d847-4293-9e1e-d3fd42f3bdec)

 1. Чтобы создать экземпляр объекта Dice, в main() функции создайте val вызываемый myFirstDice и инициализируйте его как экземпляр Dice класса. Обратите внимание на круглые скобки после имени класса, которые означают, что вы создаете новый экземпляр объекта из класса.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/6d222659-d1da-4f99-9e26-e9a3223b9189)

Теперь, когда у вас есть myFirstDice объект, вещь, созданная на основе схемы элементов, вы можете получить доступ к его свойствам. Единственным свойством Dice является its sides. Доступ к свойству осуществляется с помощью "точечной нотации". Итак, чтобы получить доступ к sides свойству myFirstDice, вы вызываете myFirstDice.sides, которое произносится как "myFirstDice точка sides".

 2. Под объявлением myFirstDiceдобавьте println() инструкцию для вывода количества sides из myFirstDice.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/3cde2743-4ed6-4d5c-bb4c-8bd3f993ec63)

---------------------------------------------------------------

Примечание: Ранее при вызове вы использовали точечную нотацию diceRange.random(). В обобщенном виде вы можете думать о точечной нотации как о том, что "над чем-то-точка -выполните некоторое действие". Например, здесь, с myFirstDice.sides надписью "в этом экземпляре получите sides свойство".

---------------------------------------------------------------

Ваш код должен выглядеть примерно так.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/32cabf99-b1cf-46d4-9c30-4c1f3c03b9a8)

 3. Запустите вашу программу, и она должна вывести количество, sides определенное в Dice классе.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/67f0e2ac-cada-4058-a2a2-34e6d25fd310)

Теперь у вас есть Dice класс и настоящая игральная кость, myFirstDice состоящая из 6 sides кубиков.

Давайте бросим кости!

### Заставьте кости броситься

Ранее вы использовали функцию для выполнения операции печати слоев торта. Бросание кубиков также является действием, которое может быть реализовано как функция. И поскольку все кости могут быть брошены, вы можете добавить функцию для этого внутри Dice класса. Функция, которая определена внутри класса, также называется методом.

 1. В Dice классе под sides переменной вставьте пустую строку, а затем создайте новую функцию для броска кубика. Начните с ключевого слова Kotlin fun, за которым следует название метода, за которым следуют круглые скобки (), за которыми следуют открывающие и закрывающие фигурные скобки {}. Вы можете оставить пустую строку между фигурными скобками, чтобы освободить место для большего количества кода, как показано ниже. Ваш класс должен выглядеть следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/a1c5350c-23ee-4310-81f0-4dcb7f2956bb)

--------------------------------------------------------------

Примечание: Вы можете назвать этот метод как угодно, но полезно дать ему имя, указывающее, какое действие он выполняет. Соглашение об именовании функций и методов должно начинаться со строчной буквы, использовать верблюжий регистр и, по возможности, начинаться с глагола действия.

---------------------------------------------------------------

Когда вы бросаете шестигранный кубик, он выдает случайное число от 1 до 6.

 2. Внутри roll() метода создайте val randomNumber. Присвойте ему случайное число в 1..6 диапазоне. Используйте точечную нотацию для вызова random() в диапазоне.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/797f68ad-5f08-4f4d-9253-4fca17790645)

 3. После генерации случайного числа выведите его на консоль. Ваш готовый roll() метод должен выглядеть как приведенный ниже код.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/a80fb682-8d1e-41e3-89d2-8112527944f3)

 4. Чтобы выполнить фактический запуск myFirstDice, в main() вызовите roll() метод on myFirstDice. Вы вызываете метод, используя "точечную нотацию". Итак, чтобы вызвать roll() метод myFirstDice, вы вводите myFirstDice.roll() текст, который произносится как "myFirstDice точка roll()".

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/73237fcd-1f94-4c0b-855b-9a29dad3cfe3)

Ваш завершенный код должен выглядеть следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/38fb9ec5-3b89-4914-b365-644603bdba42)

 5. Запустите свой код! Вы должны увидеть результат случайного броска кости под количеством сторон. Запустите свой код несколько раз и обратите внимание, что количество сторон остается неизменным, а значение броска кости меняется.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/6bb7e00c-12d2-42ee-9043-e24b2b0ea166)

Поздравляем! Вы определили Dice класс с sides переменной и roll() функцией. В main() функции вы создали новый Dice экземпляр объекта, а затем вызвали для него roll() метод для получения случайного числа.

## 4. Возвращает значение вашего броска кубика

В настоящее время вы распечатываете значение randomNumber в своей roll() функции, и это отлично работает! Но иногда более полезно возвращать результат функции тому, что вызвало функцию. Например, вы могли бы присвоить результат roll() метода переменной, а затем переместить игрока на эту величину! Давайте посмотрим, как это делается.

 1. В main() измените строку с надписью myFirstDice.roll(). Создайте val вызываемый diceRoll. Установите его равным значению, возвращаемому roll() методом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/8ccd0717-f817-487b-8118-1661892d7d18)

Это пока ничего не дает, потому что roll() пока ничего не возвращает. Чтобы этот код работал так, как задумано, roll() должен что-то возвращать.

В предыдущих codelabs вы узнали, что вам нужно указать тип данных для входных аргументов функций. Таким же образом вы должны указать тип данных для данных, которые возвращает функция.

 2. Измените roll() функцию, чтобы указать, какой тип данных будет возвращен. В этом случае случайным числом является an Int, поэтому возвращаемый тип является Int. Синтаксис для указания возвращаемого типа следующий: После имени функции, после круглых скобок добавьте двоеточие, пробел, а затем Int ключевое слово для возвращаемого типа функции. Определение функции должно выглядеть как приведенный ниже код.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/188cb5e4-3638-4d2d-a292-0d9c07016203)

 3. Запустите этот код. Вы увидите ошибку в представлении проблем. В нем говорится:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/806ab87b-9f2b-4333-af1c-1f24cf586b2f)

Вы изменили определение функции, чтобы возвращать Int, но система жалуется, что ваш код фактически не возвращает Int. "Тело блока" или "тело функции" относится к коду функции, заключенному в фигурные скобки. Вы можете исправить эту ошибку, вернув значение из функции с помощью return инструкции в конце тела функции.

 4. В roll()удалите println() инструкцию и замените ее return инструкцией for randomNumber. Ваша roll() функция должна выглядеть как приведенный ниже код.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/57175873-2d18-4b6c-bbd0-b55602adc5de)

 5. В main() удалите инструкцию print для сторон кубика.

 6. Добавьте инструкцию для вывода значения sides и diceRoll в информативном предложении. Ваша готовая main() функция должна выглядеть аналогично приведенному ниже коду.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/02208ed4-6eff-4db2-8802-7fd91f4bfb0b)

 7. Запустите свой код, и результат должен быть таким.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/8911c02c-734b-4166-8107-968d919f57d4)

Вот весь ваш код на данный момент.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/4294c30b-88e0-47b2-a721-87c9a3e75d67)

## 5. Измените количество сторон на ваших кубиках

Не у всех кубиков 6 сторон! Кубики бывают всех форм и размеров: 4 стороны, 8 сторон, до 120 сторон!

 1. В вашем Dice классе, в вашем roll() методе измените жестко запрограммированный 1..6 на use sides вместо этого, чтобы диапазон и, следовательно, случайное число, всегда соответствовали количеству сторон.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/1f590358-caf4-4c13-8642-a146e4331b7f)

 2. В main() функции ниже и после печати броска кубика измените значение sides of myFirstDice на 20.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/91519a14-3d6a-479e-b36a-52449f3f1353)

 3. Скопируйте и вставьте существующую инструкцию print ниже после того, как вы изменили количество сторон.

 4. Замените вывод diceRoll на вывод результата вызова roll() метода на myFirstDice.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/f9ef0eea-b230-4269-9abe-afc48aff8176)

Ваша программа должна выглядеть следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/5fad7130-090f-4836-a26c-8a0a131dbbd5)

 5. Запустите свою программу, и вы должны увидеть сообщение для 6-стороннего кубика и второе сообщение для 20-стороннего кубика.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/523c8468-583f-4608-909f-31ace5af36c7)

## 6. Настройте свой dice

Идея класса состоит в том, чтобы представлять вещь, часто что-то физическое в реальном мире. В этом случае Dice класс действительно представляет физическую игральную кость. В реальном мире кости не могут изменять количество сторон. Если вы хотите другое количество сторон, вам нужно получить другие кости. Программно это означает, что вместо изменения свойства sides существующего Dice экземпляра объекта вам следует создать новый экземпляр объекта dice с нужным вам количеством сторон.

В этой задаче вы собираетесь изменить Dice класс, чтобы при создании нового экземпляра можно было указать количество сторон. Измените Dice определение класса, чтобы вы могли указать количество сторон. Это похоже на то, как функция может принимать аргументы для ввода.

 1. Измените Dice определение класса, чтобы оно принимало целое число с именем numSides. Код внутри вашего класса не изменится.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/a9e015be-7731-4734-a4f5-570330b0ee6a)

 2. Внутри Dice класса удалите sides переменную, которую теперь можно использовать numSides.

 3. Кроме того, исправьте диапазон для использования numSides.

Ваш Dice класс должен выглядеть следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/188453ef-ab47-4a65-b488-55f7b92aea51)

Если вы запустите этот код, вы увидите множество ошибок, потому что вам нужно обновить main() для работы с изменениями в Dice классе.

 4. В main()для создания myFirstDice с 6 сторонами теперь необходимо указать количество сторон в качестве аргумента для Dice класса, как показано ниже.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/75ea364d-fa4b-4eb5-bfff-3f5145b97223)

 5. В инструкции print измените sides на numSides.

 6. Ниже удалите код, который изменяется sides на 20, поскольку эта переменная больше не существует.

 7. Также удалите println инструкцию под ним.

Ваша main() функция должна выглядеть как приведенный ниже код, и если вы запустите ее, ошибок быть не должно.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/3925e8b5-76fc-4687-8782-ccc997ff1f6b)

 8. После печати первого броска кубика добавьте код для создания и печати второго Dice объекта с именем mySecondDice с 20 сторонами.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/b334e778-d649-4f85-a42c-f4518787ca92)

 9. Добавьте инструкцию print, которая выполняет свертку и выводит возвращаемое значение.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/630b3ca2-8cdb-474b-a54d-81fa67e46fad)

 10. Ваша готовая main() функция должна выглядеть следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/efbda195-422f-4110-bb0b-aab7c8de1677)

 11. Запустите готовую программу, и ваш результат должен выглядеть следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/4e1e5c4e-6572-45d8-beba-a555a5c362e0)

## 7. Внедряйте передовые методы кодирования

При написании кода лучше использовать краткость. Вы можете избавиться от randomNumber переменной и напрямую возвращать случайное число.

 1. Измените return оператор, чтобы возвращать случайное число напрямую.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/473ec45f-464e-4367-94fb-8509f910a8bb)

Во второй инструкции print вы помещаете вызов для получения случайного числа в строковый шаблон. Вы можете избавиться от diceRoll переменной, выполнив то же самое в первой инструкции print.

 2. Вызовите myFirstDice.roll() в шаблоне string и удалите diceRoll переменную. Первые две строки вашего main() кода теперь выглядят следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/7196d936-cdea-4eb9-a54d-3cd9c0c25708)

 3. Запустите свой код, и на выходе не должно быть никакой разницы.

--------------------------------------------------------------

Примечание: Изменение кода, чтобы сделать его короче, эффективнее или проще для чтения и понимания, называется рефакторингом. Это похоже на написание документа, где вы составляете первый черновик, содержащий всю информацию, а затем редактируете и уточняете свои слова.

---------------------------------------------------------------

Это ваш окончательный код после рефакторинга .

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/ef577527-e1b0-47fb-9f43-e51fefbfc0a9)

## 8. Краткие сведения

 * Вызовите random() функцию для IntRange, чтобы сгенерировать случайное число: (1..6).random()

 * Классы подобны схеме объекта. Они могут иметь свойства и поведение, реализованные в виде переменных и функций.

 * Экземпляр класса представляет объект, часто физический объект, такой как игральная кость. Вы можете вызывать действия над объектом и изменять его атрибуты.

 * Вы можете указать значения классу при создании экземпляра. Например: class Dice(val numSides: Int) а затем создать экземпляр с помощью Dice(6).

 * Функции могут возвращать что-то. Укажите тип данных, который должен быть возвращен в определении функции, и используйте return инструкцию в теле функции, чтобы вернуть что-то. Например: fun example(): Int { return 5 }

# Создайте интерактивное приложение для игры в кости

## 1. Прежде чем начать

В этой кодовой лаборатории вы создадите приложение для игры в кости для Android, в котором пользователи смогут щелкнуть Button в приложении, чтобы бросить кости. Результат броска будет показан на экране в виде TextView.

Вы будете использовать редактор макетов в Android Studio для создания макета своего приложения, а затем напишите код Kotlin для того, что происходит при щелчке на Button.

### Предварительные требования

 * Как создать и запустить приложение "Привет, мир!" в Android Studio.

 * Знакомы с использованием TextViews в приложении.

 * Как изменить атрибуты a TextView в редакторе макетов.

 * Как извлечь текст в строковый ресурс, чтобы упростить перевод вашего приложения и повторное использование строк.

 * Основы программирования Kotlin

### Чему вы научитесь

 - Как добавить Button в приложение для Android.

 - Как добавить поведение при нажатии на Button в приложении.

 - Как открыть Activity код приложения и изменить его.

 - Как отобразить Toast сообщение.

 - Как обновить содержимое TextView во время работы приложения.

### Что вы создадите

 * Приложение Dice Roller для Android, в котором есть Button возможность бросать кости и обновлять текст на экране результатом броска.

### Что вам нужно

 * Компьютер с установленной Android Studio.

Вот как будет выглядеть приложение, когда вы заполните эту кодовую таблицу.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/7345f990-99f4-4ff3-8391-b071d367f5ca)



