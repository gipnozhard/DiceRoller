# DiceRoller

## 1. Прежде чем вы начнете

Для кодовых лабораторий в этом пути вы будете создавать приложение Dice Roller для Android. Когда пользователь "бросает кости", будет сгенерирован случайный результат. В результате учитывается количество сторон кубика. Например, из 6-стороннего кубика можно выпадать только значения от 1 до 6.

Так будет выглядеть конечное приложение.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/33bf7dcb-c3db-4cf7-843a-d292659c0cfc)

Чтобы помочь вам сосредоточиться на новых концепциях программирования для этого приложения, вы будете использовать браузерный инструмент программирования Kotlin для создания основных функциональных возможностей приложения. Программа выведет ваши результаты на консоль. Позже вы будете реализовывать пользовательский интерфейс в Android Studio.

В этой первой кодовой лаборатории вы создадите программу Kotlin, которая имитирует бросание игральных костей и выдает случайное число, точно так же, как это делают игральные кости.

### Предварительные требования:

 * Как открывать, редактировать и запускать код в https://developer.android.com/training/kotlinplayground

 * Создайте и запустите программу Kotlin, которая использует переменные и функции и выводит результат на консоль.

 * Форматируйте числа в тексте, используя строковый шаблон с ${variable} обозначением.

### Чему вы научитесь:

 - Как программно генерировать случайные числа для имитации бросков костей.

 - Как структурировать свой код, создав Dice класс с переменной и методом.

 - Как создать экземпляр объекта класса, изменить его переменные и вызвать его методы.

### Что вы будете создавать:

 * Программа Kotlin в браузерном инструменте программирования Kotlin, которая может выполнять случайный бросок кости.

### Что вам нужно:

 * Компьютер с подключением к Интернету

## 2. Набирайте случайные числа

В играх часто присутствует элемент случайности. Вы можете получить случайный приз или продвинуться на случайное количество шагов по игровому полю. В повседневной жизни вы можете использовать случайные числа и буквы для создания безопасных паролей!

Вместо того, чтобы бросать реальные кости, вы можете написать программу, которая имитирует бросание костей для вас. Каждый раз, когда вы бросаете кости, результатом может быть любое число в диапазоне возможных значений. К счастью, вам не нужно создавать свой собственный генератор случайных чисел для такой программы. Большинство языков программирования, включая Kotlin, имеют встроенный способ генерации случайных чисел. В этой задаче вы будете использовать код Kotlin для генерации случайного числа.

### Настройте свой начальный код

 1. Откройте веб-сайт в своем браузере https://developer.android.com/training/kotlinplayground.

 2. Удалите весь существующий код в редакторе кода и замените его приведенным ниже кодом. Это main() функция, с которой вы работали в более ранних codelabs.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/5294b418-4b44-4380-9587-d1b81075d8c8)

### Используйте функцию random

Чтобы бросить кости, вам нужен способ представления всех допустимых значений бросков костей. Для обычных 6-гранных костей допустимыми бросками костей являются: 1, 2, 3, 4, 5, и 6.

Ранее вы узнали, что существуют такие типы данных, как Int для целых чисел и String для текста. IntRange - это другой тип данных, и он представляет диапазон целых чисел от начальной точки до конечной. IntRange - это подходящий тип данных для представления возможных значений, которые может дать бросок кости.

 1. Внутри вашей main() функции определите переменную как val вызываемую diceRange. Присвоите ему значение IntRange от 1 до 6, представляющее диапазон целых чисел, которые может бросить шестигранный кубик.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/bf3f5f14-0b13-44b4-81df-6bb69d332773)

Вы можете сказать, что 1..6 это диапазон Kotlin, потому что у него есть начальный номер, две точки, за которыми следует конечный номер (без пробелов между ними). Другими примерами диапазонов целых чисел являются 2..5 для чисел от 2 до 5 и 100..200 для чисел от 100 до 200.

----------------------------------------------------------------

Совет: Обратите внимание, что в этом определении не указано IntRange, точно так же, как вам не нужно было указывать Int or String при создании переменной для целого числа или строки. В большинстве случаев система может определить, какой тип данных вы собираетесь использовать.

Например, система интерпретирует это:

 val diceRange = 1..6

поскольку это:

 val diceRange: IntRange = 1..6

-----------------------------------------------------------------

Аналогично тому, как вызов println() сообщает системе напечатать заданный текст, вы можете использовать вызываемую функцию random() для генерации и возврата случайного числа для вас в заданном диапазоне. Как и раньше, вы можете сохранить результат в переменной.

 2. Внутри main() определите переменную как val вызываемую randomNumber.
 
 3. Сделайте так, чтобы у randomNumber результата вызова было значение random() в diceRange диапазоне, как показано ниже.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/9c1c1211-91ec-4f4e-ac28-b6c8f6cf7328)

Обратите внимание, что вы вызываете random() on diceRange, используя точку между переменной и вызовом функции. Вы можете прочитать это как "генерация случайного числа из diceRange". Затем результат сохраняется в randomNumber переменной.

 4. Чтобы увидеть случайно сгенерированное число, используйте нотацию форматирования строки (также называемую "шаблон строки") ${randomNumber} для его печати, как показано ниже.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/79142c2a-7954-452a-a86b-c42c105a2658)

Ваш готовый код должен выглядеть следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/31221225-2d86-4994-8f6d-44708bacc203)

 5. Запустите свой код несколько раз. Каждый раз вы должны видеть вывод, как показано ниже, с разными случайными числами


![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/d9968ee2-a915-4b5b-8ab7-5244f74de3ec)

---------------------------------------------------------------

 Советы по диапазонам:

 * Диапазоны могут составлять любые целые числа. Допустимыми диапазонами являются следующие: 3..46, 0..270, -6..+6, -10..-4.

 * Вы можете вызывать функции непосредственно в диапазоне, например: (1..6).random().

----------------------------------------------------------------

## 3. Создайте класс Dice

Когда вы бросаете кости, они становятся реальными объектами в ваших руках. Хотя код, который вы только что написали, работает отлично, трудно представить, что речь идет о реальных кубиках. Организация программы так, чтобы она была больше похожа на то, что она представляет, облегчает ее понимание. Итак, было бы здорово иметь программные кости, которые вы можете бросать!

Все кубики работают по существу одинаково. Они обладают одинаковыми свойствами, такими как стороны, и у них одинаковое поведение, например, их можно бросать. В Kotlin вы можете создать программный чертеж кости, в котором указано, что кости имеют стороны и могут выпадать случайным числом. Этот чертеж называется классом.

Затем на основе этого класса вы можете создавать реальные объекты dice, называемые экземплярами объектов. Например, вы можете создать 12-сторонний кубик или 4-сторонний кубик.

--------------------------------------------------------------

Совет: Класс подобен тому, как чертежные планы архитектора - это не сам дом; это инструкции о том, как построить дом. Дом - это реальная вещь, или экземпляр объекта, созданный в соответствии с планом.

---------------------------------------------------------------

---------------------------------------------------------------

Примечание: Организация всего, что связано с dice, в класс называется инкапсуляцией. Инкапсуляция - это большое причудливое слово, но все, что оно означает, это то, что вы можете поместить функциональность, которая логически связана, в одно место.

---------------------------------------------------------------
 
### Определите класс Dice

На следующих шагах вы определите новый класс с именем Dice для представления игральной кости, которую можно бросать.

 1. Чтобы начать заново, очистите код в main() функции, чтобы в конечном итоге получить код, как показано ниже.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/cfc944a7-8d67-4d96-94fd-8387f3782b04)

 2. Под этой main() функцией добавьте пустую строку, а затем добавьте код для создания Dice класса. Как показано ниже, начните с ключевого слова class, за которым следует название класса, а затем открывающая и закрывающая фигурные скобки. Оставьте пробел между фигурными скобками, чтобы поместить ваш код для класса.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/314065d9-aeb2-4395-94d5-c5bdf9a56a1d)

--------------------------------------------------------------

Примечание:

 * Аналогично использованию fun ключевого слова в Kotlin для создания новой функции, используйте class ключевое слово для создания нового класса.

 * Вы можете выбрать любое имя для class, но полезно, если имя указывает, что представляет класс. По соглашению, имя класса записывается в верхнем регистре Camel (также называемом оболочкой Pascal). Например: Car, ParkingMeter и CustomerRecord все допустимые имена классов, и вы можете догадаться, что они представляют.

---------------------------------------------------------------

Внутри определения класса вы можете указать одно или несколько свойств для класса с помощью переменных. Реальные кости могут иметь несколько сторон, цвет или вес. В этой задаче вы сосредоточитесь на свойстве количества сторон кубика.

 3. Внутри Dice класса добавьте var called sides для обозначения количества сторон, которые будут иметь ваши кости. Установите sides значение 6.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/816989ce-3b7f-4631-b352-0bed52a279e9)

Вот и все. Теперь у вас есть очень простой класс, представляющий dice.

### Создайте экземпляр класса Dice

С помощью этого Dice класса у вас есть общее представление о том, что такое dice. Чтобы иметь реальную dice в вашей программе, вам необходимо создать Dice экземпляр объекта. (И если бы вам понадобилось иметь три кубика, вы бы создали три экземпляра объекта.)

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/aa9f2b43-d847-4293-9e1e-d3fd42f3bdec)

 1. Чтобы создать экземпляр объекта Dice, в main() функции создайте val вызываемый myFirstDice и инициализируйте его как экземпляр Dice класса. Обратите внимание на круглые скобки после имени класса, которые означают, что вы создаете новый экземпляр объекта из класса.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/6d222659-d1da-4f99-9e26-e9a3223b9189)

Теперь, когда у вас есть myFirstDice объект, вещь, созданная на основе схемы элементов, вы можете получить доступ к его свойствам. Единственным свойством Dice является its sides. Доступ к свойству осуществляется с помощью "точечной нотации". Итак, чтобы получить доступ к sides свойству myFirstDice, вы вызываете myFirstDice.sides, которое произносится как "myFirstDice точка sides".

 2. Под объявлением myFirstDiceдобавьте println() инструкцию для вывода количества sides из myFirstDice.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/3cde2743-4ed6-4d5c-bb4c-8bd3f993ec63)

---------------------------------------------------------------

Примечание: Ранее при вызове вы использовали точечную нотацию diceRange.random(). В обобщенном виде вы можете думать о точечной нотации как о том, что "над чем-то-точка -выполните некоторое действие". Например, здесь, с myFirstDice.sides надписью "в этом экземпляре получите sides свойство".

---------------------------------------------------------------

Ваш код должен выглядеть примерно так.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/32cabf99-b1cf-46d4-9c30-4c1f3c03b9a8)

 3. Запустите вашу программу, и она должна вывести количество, sides определенное в Dice классе.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/67f0e2ac-cada-4058-a2a2-34e6d25fd310)

Теперь у вас есть Dice класс и настоящая игральная кость, myFirstDice состоящая из 6 sides кубиков.

Давайте бросим кости!

### Заставьте кости броситься

Ранее вы использовали функцию для выполнения операции печати слоев торта. Бросание кубиков также является действием, которое может быть реализовано как функция. И поскольку все кости могут быть брошены, вы можете добавить функцию для этого внутри Dice класса. Функция, которая определена внутри класса, также называется методом.

 1. В Dice классе под sides переменной вставьте пустую строку, а затем создайте новую функцию для броска кубика. Начните с ключевого слова Kotlin fun, за которым следует название метода, за которым следуют круглые скобки (), за которыми следуют открывающие и закрывающие фигурные скобки {}. Вы можете оставить пустую строку между фигурными скобками, чтобы освободить место для большего количества кода, как показано ниже. Ваш класс должен выглядеть следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/a1c5350c-23ee-4310-81f0-4dcb7f2956bb)

--------------------------------------------------------------

Примечание: Вы можете назвать этот метод как угодно, но полезно дать ему имя, указывающее, какое действие он выполняет. Соглашение об именовании функций и методов должно начинаться со строчной буквы, использовать верблюжий регистр и, по возможности, начинаться с глагола действия.

---------------------------------------------------------------

Когда вы бросаете шестигранный кубик, он выдает случайное число от 1 до 6.

 2. Внутри roll() метода создайте val randomNumber. Присвойте ему случайное число в 1..6 диапазоне. Используйте точечную нотацию для вызова random() в диапазоне.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/797f68ad-5f08-4f4d-9253-4fca17790645)

 3. После генерации случайного числа выведите его на консоль. Ваш готовый roll() метод должен выглядеть как приведенный ниже код.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/a80fb682-8d1e-41e3-89d2-8112527944f3)

 4. Чтобы выполнить фактический запуск myFirstDice, в main() вызовите roll() метод on myFirstDice. Вы вызываете метод, используя "точечную нотацию". Итак, чтобы вызвать roll() метод myFirstDice, вы вводите myFirstDice.roll() текст, который произносится как "myFirstDice точка roll()".

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/73237fcd-1f94-4c0b-855b-9a29dad3cfe3)

Ваш завершенный код должен выглядеть следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/38fb9ec5-3b89-4914-b365-644603bdba42)

 5. Запустите свой код! Вы должны увидеть результат случайного броска кости под количеством сторон. Запустите свой код несколько раз и обратите внимание, что количество сторон остается неизменным, а значение броска кости меняется.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/6bb7e00c-12d2-42ee-9043-e24b2b0ea166)

Поздравляем! Вы определили Dice класс с sides переменной и roll() функцией. В main() функции вы создали новый Dice экземпляр объекта, а затем вызвали для него roll() метод для получения случайного числа.

## 4. Возвращает значение вашего броска кубика

В настоящее время вы распечатываете значение randomNumber в своей roll() функции, и это отлично работает! Но иногда более полезно возвращать результат функции тому, что вызвало функцию. Например, вы могли бы присвоить результат roll() метода переменной, а затем переместить игрока на эту величину! Давайте посмотрим, как это делается.

 1. В main() измените строку с надписью myFirstDice.roll(). Создайте val вызываемый diceRoll. Установите его равным значению, возвращаемому roll() методом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/8ccd0717-f817-487b-8118-1661892d7d18)

Это пока ничего не дает, потому что roll() пока ничего не возвращает. Чтобы этот код работал так, как задумано, roll() должен что-то возвращать.

В предыдущих codelabs вы узнали, что вам нужно указать тип данных для входных аргументов функций. Таким же образом вы должны указать тип данных для данных, которые возвращает функция.

 2. Измените roll() функцию, чтобы указать, какой тип данных будет возвращен. В этом случае случайным числом является an Int, поэтому возвращаемый тип является Int. Синтаксис для указания возвращаемого типа следующий: После имени функции, после круглых скобок добавьте двоеточие, пробел, а затем Int ключевое слово для возвращаемого типа функции. Определение функции должно выглядеть как приведенный ниже код.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/188cb5e4-3638-4d2d-a292-0d9c07016203)

 3. Запустите этот код. Вы увидите ошибку в представлении проблем. В нем говорится:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/806ab87b-9f2b-4333-af1c-1f24cf586b2f)

Вы изменили определение функции, чтобы возвращать Int, но система жалуется, что ваш код фактически не возвращает Int. "Тело блока" или "тело функции" относится к коду функции, заключенному в фигурные скобки. Вы можете исправить эту ошибку, вернув значение из функции с помощью return инструкции в конце тела функции.

 4. В roll()удалите println() инструкцию и замените ее return инструкцией for randomNumber. Ваша roll() функция должна выглядеть как приведенный ниже код.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/57175873-2d18-4b6c-bbd0-b55602adc5de)

 5. В main() удалите инструкцию print для сторон кубика.

 6. Добавьте инструкцию для вывода значения sides и diceRoll в информативном предложении. Ваша готовая main() функция должна выглядеть аналогично приведенному ниже коду.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/02208ed4-6eff-4db2-8802-7fd91f4bfb0b)

 7. Запустите свой код, и результат должен быть таким.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/8911c02c-734b-4166-8107-968d919f57d4)

Вот весь ваш код на данный момент.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/4294c30b-88e0-47b2-a721-87c9a3e75d67)

## 5. Измените количество сторон на ваших кубиках

Не у всех кубиков 6 сторон! Кубики бывают всех форм и размеров: 4 стороны, 8 сторон, до 120 сторон!

 1. В вашем Dice классе, в вашем roll() методе измените жестко запрограммированный 1..6 на use sides вместо этого, чтобы диапазон и, следовательно, случайное число, всегда соответствовали количеству сторон.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/1f590358-caf4-4c13-8642-a146e4331b7f)

 2. В main() функции ниже и после печати броска кубика измените значение sides of myFirstDice на 20.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/91519a14-3d6a-479e-b36a-52449f3f1353)

 3. Скопируйте и вставьте существующую инструкцию print ниже после того, как вы изменили количество сторон.

 4. Замените вывод diceRoll на вывод результата вызова roll() метода на myFirstDice.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/f9ef0eea-b230-4269-9abe-afc48aff8176)

Ваша программа должна выглядеть следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/5fad7130-090f-4836-a26c-8a0a131dbbd5)

 5. Запустите свою программу, и вы должны увидеть сообщение для 6-стороннего кубика и второе сообщение для 20-стороннего кубика.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/523c8468-583f-4608-909f-31ace5af36c7)

## 6. Настройте свой dice

Идея класса состоит в том, чтобы представлять вещь, часто что-то физическое в реальном мире. В этом случае Dice класс действительно представляет физическую игральную кость. В реальном мире кости не могут изменять количество сторон. Если вы хотите другое количество сторон, вам нужно получить другие кости. Программно это означает, что вместо изменения свойства sides существующего Dice экземпляра объекта вам следует создать новый экземпляр объекта dice с нужным вам количеством сторон.

В этой задаче вы собираетесь изменить Dice класс, чтобы при создании нового экземпляра можно было указать количество сторон. Измените Dice определение класса, чтобы вы могли указать количество сторон. Это похоже на то, как функция может принимать аргументы для ввода.

 1. Измените Dice определение класса, чтобы оно принимало целое число с именем numSides. Код внутри вашего класса не изменится.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/a9e015be-7731-4734-a4f5-570330b0ee6a)

 2. Внутри Dice класса удалите sides переменную, которую теперь можно использовать numSides.

 3. Кроме того, исправьте диапазон для использования numSides.

Ваш Dice класс должен выглядеть следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/188453ef-ab47-4a65-b488-55f7b92aea51)

Если вы запустите этот код, вы увидите множество ошибок, потому что вам нужно обновить main() для работы с изменениями в Dice классе.

 4. В main()для создания myFirstDice с 6 сторонами теперь необходимо указать количество сторон в качестве аргумента для Dice класса, как показано ниже.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/75ea364d-fa4b-4eb5-bfff-3f5145b97223)

 5. В инструкции print измените sides на numSides.

 6. Ниже удалите код, который изменяется sides на 20, поскольку эта переменная больше не существует.

 7. Также удалите println инструкцию под ним.

Ваша main() функция должна выглядеть как приведенный ниже код, и если вы запустите ее, ошибок быть не должно.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/3925e8b5-76fc-4687-8782-ccc997ff1f6b)

 8. После печати первого броска кубика добавьте код для создания и печати второго Dice объекта с именем mySecondDice с 20 сторонами.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/b334e778-d649-4f85-a42c-f4518787ca92)

 9. Добавьте инструкцию print, которая выполняет свертку и выводит возвращаемое значение.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/630b3ca2-8cdb-474b-a54d-81fa67e46fad)

 10. Ваша готовая main() функция должна выглядеть следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/efbda195-422f-4110-bb0b-aab7c8de1677)

 11. Запустите готовую программу, и ваш результат должен выглядеть следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/4e1e5c4e-6572-45d8-beba-a555a5c362e0)

## 7. Внедряйте передовые методы кодирования

При написании кода лучше использовать краткость. Вы можете избавиться от randomNumber переменной и напрямую возвращать случайное число.

 1. Измените return оператор, чтобы возвращать случайное число напрямую.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/473ec45f-464e-4367-94fb-8509f910a8bb)

Во второй инструкции print вы помещаете вызов для получения случайного числа в строковый шаблон. Вы можете избавиться от diceRoll переменной, выполнив то же самое в первой инструкции print.

 2. Вызовите myFirstDice.roll() в шаблоне string и удалите diceRoll переменную. Первые две строки вашего main() кода теперь выглядят следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/7196d936-cdea-4eb9-a54d-3cd9c0c25708)

 3. Запустите свой код, и на выходе не должно быть никакой разницы.

--------------------------------------------------------------

Примечание: Изменение кода, чтобы сделать его короче, эффективнее или проще для чтения и понимания, называется рефакторингом. Это похоже на написание документа, где вы составляете первый черновик, содержащий всю информацию, а затем редактируете и уточняете свои слова.

---------------------------------------------------------------

Это ваш окончательный код после рефакторинга .

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/ef577527-e1b0-47fb-9f43-e51fefbfc0a9)

## 8. Краткие сведения

 * Вызовите random() функцию для IntRange, чтобы сгенерировать случайное число: (1..6).random()

 * Классы подобны схеме объекта. Они могут иметь свойства и поведение, реализованные в виде переменных и функций.

 * Экземпляр класса представляет объект, часто физический объект, такой как игральная кость. Вы можете вызывать действия над объектом и изменять его атрибуты.

 * Вы можете указать значения классу при создании экземпляра. Например: class Dice(val numSides: Int) а затем создать экземпляр с помощью Dice(6).

 * Функции могут возвращать что-то. Укажите тип данных, который должен быть возвращен в определении функции, и используйте return инструкцию в теле функции, чтобы вернуть что-то. Например: fun example(): Int { return 5 }

# Создайте интерактивное приложение для игры в кости

## 1. Прежде чем начать

В этой кодовой лаборатории вы создадите приложение для игры в кости для Android, в котором пользователи смогут щелкнуть Button в приложении, чтобы бросить кости. Результат броска будет показан на экране в виде TextView.

Вы будете использовать редактор макетов в Android Studio для создания макета своего приложения, а затем напишите код Kotlin для того, что происходит при щелчке на Button.

### Предварительные требования

 * Как создать и запустить приложение "Привет, мир!" в Android Studio.

 * Знакомы с использованием TextViews в приложении.

 * Как изменить атрибуты a TextView в редакторе макетов.

 * Как извлечь текст в строковый ресурс, чтобы упростить перевод вашего приложения и повторное использование строк.

 * Основы программирования Kotlin

### Чему вы научитесь

 - Как добавить Button в приложение для Android.

 - Как добавить поведение при нажатии на Button в приложении.

 - Как открыть Activity код приложения и изменить его.

 - Как отобразить Toast сообщение.

 - Как обновить содержимое TextView во время работы приложения.

### Что вы создадите

 * Приложение Dice Roller для Android, в котором есть Button возможность бросать кости и обновлять текст на экране результатом броска.

### Что вам нужно

 * Компьютер с установленной Android Studio.

Вот как будет выглядеть приложение, когда вы заполните эту кодовую таблицу.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/7345f990-99f4-4ff3-8391-b071d367f5ca)

## 2. Настройте свое приложение

### Создайте пустой проект Activity

 1. Если у вас уже есть существующий проект, открытый в Android Studio, перейдите в Файл> Создать> Новый проект ... 
чтобы открыть экран Создать новый проект.

 2. В Создать новый проект создайте новый проект Kotlin, используя шаблон Пустое действие.

 3. Назовите приложение "Dice Roller" с минимальным уровнем API 19 (KitKat).

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/3b9d7d06-c984-465a-88e3-39c2caf1d330)

Запустите новое приложение, и оно должно выглядеть следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/184846c0-7a74-4502-bff3-d0c9c959475c)

## 3. Создайте макет для приложения

### Откройте редактор макетов

 1. В окне Проекта дважды щелкните activity_main.xml (приложение > разрешение> макет>activity_main.xml), чтобы открыть его. Вы должны увидеть редактор макетов, только с надписью "Hello World" TextView в центре приложения.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/cc58c868-4a99-4818-820e-d9b69ece5265)

Затем вы добавите a Button в свое приложение. A Button - это элемент пользовательского интерфейса в Android, который пользователь может нажать для выполнения действия.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/e2ea0594-2e2e-45f0-9f91-5438af859f42)

В этой задаче вы добавляете Button под надписью "Привет, мир" TextView. TextView и Button будут расположены внутри ConstraintLayout, которое является типом ViewGroup.

Когда они есть Views внутри ViewGroup, они Views считаются дочерними по отношению к родителю ViewGroup. В случае вашего приложения TextView и Button будут считаться дочерними элементами родительского ConstraintLayout.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/85c58914-5407-41c3-8a8c-1c89a159a77d)

Добавьте a Button в качестве дочернего элемента существующего ConstraintLayout в вашем приложении.

---------------------------------------------------------------

Примечание: Как и в генеалогическом древе, в иерархии представлений родительские представления сами по себе могут быть дочерними представлениями, а дочерние представления могут быть родителями для других дочерних представлений.

---------------------------------------------------------------

### Добавьте кнопку в макет

 1. Перетащите символ Button из палитры в представление Дизайн, расположив его под надписью "Hello World" TextView.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/cdb8c177-1357-4e49-8bf3-a5384b5d89b6)

 2. Под палитрой в дереве компонентов убедитесь, что Button и TextView указаны под ConstraintLayout (как дочерние элементы ConstraintLayout).

 3. Обратите внимание на ошибку, что Button не ограничено. Поскольку Button находится внутри ConstraintLayout, вы должны установить вертикальные и горизонтальные ограничения для его позиционирования.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/1c4737ed-8d34-4e75-a38c-6db393548b83)

### Расположите кнопку

На этом шаге вы добавите вертикальное ограничение от верхней части Button до нижней TextView. Это расположит Button под TextView.

 1. В режиме Дизайн, у верхнего края Button, нажмите и удерживайте белый круг с синей рамкой. Перетащите указатель, и за указателем появится стрелка. Отпустите, когда дойдете до нижнего края надписи "Hello World"TextView. При этом устанавливается ограничение на расположение, и Button картинка скользит вверх, оказавшись чуть ниже TextView.

![777](https://github.com/gipnozhard/DiceRoller/assets/71705375/10b0770c-c789-4c59-82f0-3d8671c426fc)

 2. Посмотрите на атрибуты в правой части редактора макетов.

 3. В виджете ограничений обратите внимание на новое ограничение макета, которое установлено в нижней части TextView, Top → BottomOf TextView (0dp). (0dp) означает, что запас равен 0. У вас также ошибка из-за отсутствия горизонтальных ограничений.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/01aa320d-cec4-46ea-b33f-a009c7004be0)

 4. Добавьте горизонтальное ограничение с левой стороны Button к левой стороне родительского элемента ConstraintLayout.

 5. Повторите с правой стороны, соединив правый край Button с правым краем ConstraintLayout. Результат должен выглядеть примерно так:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/0ff61d0a-0a56-4794-8dcd-8b033ff26595)

 6. ButtonПо-прежнему выбранный виджет ограничений должен выглядеть следующим образом. Обратите внимание на два дополнительных ограничения, которые были добавлены: Start → Начало родительского элемента (0dp) и End → Завершение родительского элемента (0dp). Это означает, что игра Button центрирована по горизонтали в своем родительском приложении ConstraintLayout.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/9359a734-bc98-47c8-8375-97f07a3c97b9)

 7. Запустите приложение. Оно должно выглядеть как на скриншоте ниже. Вы можете нажать на Button, но это пока ничего не дает. Давайте продолжим!

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/0dfe4733-1b61-4885-b0b1-0561dd6f5fb0)

### Измените текст кнопки

Вы собираетесь внести еще пару изменений в пользовательский интерфейс в редакторе макетов.

Вместо Button надписи с надписью "Кнопка" измените ее на что-нибудь, указывающее, что кнопка собирается делать: "Бросок".

 1. В редакторе макетов, Button выбрав, перейдите к Атрибутам, измените текст на Roll и нажмите клавишу Enter (Return на Mac).

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/d79ff64c-a8fe-400a-a337-412068b6f7b8)

 2. В дереве компонентов рядом с Button появляется оранжевый предупреждающий треугольник. При наведении указателя на треугольник появляется сообщение. Android Studio обнаружила жестко закодированную строку ("Roll") в коде вашего приложения и предлагает использовать вместо нее строковый ресурс.

Наличие жестко закодированной строки означает, что приложение будет сложнее переводить на другие языки и сложнее повторно использовать строки в разных частях вашего приложения. К счастью, в Android Studio есть автоматическое исправление для вас.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/de888780-617c-4630-8e9b-f6b85b0366e6)

 3. В дереве компонентов щелкните по оранжевому треугольнику.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/0e77bdb8-6eab-4bc8-b9c3-980150777c8f)

Откроется полное предупреждающее сообщение.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/bf47c1c2-922a-49aa-a642-8123dc5e8990)

 4. В нижней части сообщения, в разделе "Предлагаемое исправление", нажмите кнопку "Исправить". (Возможно, вам потребуется прокрутить вниз.)

 5. Откроется диалоговое окно "Извлечь ресурс". Извлечь строку означает взять текст "Roll" и создать строковый ресурс, вызываемый roll в strings.xml (app> res> values> strings.xml ). Значения по умолчанию верны, поэтому нажмите OK.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/7681597e-84b5-485a-bae4-abb1cc5753ee)

 6. Обратите внимание, что в атрибутах в текстовом атрибуте для Button now указано @string/roll, что относится к только что созданному вами ресурсу.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/6c3fe4a5-c514-4b39-9a6f-ed278f4b9121)

В представлении дизайна на нем по-прежнему должно быть написано ButtonRollБросок.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/53ecba8a-76dd-4ee8-9998-404e4dbd393e)

### Оформите текстовое представление

"Привет, мир!" текст довольно маленький, и сообщение не относится к вашему приложению. На этом шаге вы замените маленькое сообщение "Привет, мир!" цифрой, чтобы показать выпавшее значение, и увеличите шрифт, чтобы его было легче разглядеть.

 1. В редакторе дизайна выберите TextView, чтобы его атрибуты отображались в окне Атрибуты.

 2. Измените textSize TextViewна 36sp, чтобы оно было большим и легко читаемым. Возможно, вам потребуется прокрутить страницу, чтобы найти textSize.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/9270e806-4dab-4889-9b8b-01f505bac103)

Очистите атрибут textTextView. Вам не нужно ничего отображать в TextView, пока пользователь не бросит кости.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/a5064ec7-68c6-482d-a53d-3a976cb39b2c)

Однако очень полезно видеть текст в TextView, когда вы редактируете макет и код своего приложения. Для этой цели вы можете добавить в TextView текст, который виден только при предварительном просмотре макета, но не при запуске приложения.

 4. Выберите TextView в дереве компонентов.

 5. В разделе Общие атрибуты найдите атрибут text, а под ним другой текстовый атрибут со значком инструмента. Атрибут text - это то, что будет отображаться пользователю при запуске приложения. Атрибут text со значком инструмента - это атрибут "tools text", который предназначен только для вас как разработчика.

 6. Установите для текста tools значение "1" в TextView (чтобы представить, что у вас бросок кости равен 1). "1" будет отображаться только в редакторе дизайна Android Studio, но оно не будет отображаться при запуске приложения на реальном устройстве или эмуляторе.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/5562e5fe-9724-4bf8-ba6f-492ed584e531)

Обратите внимание, что, поскольку этот текст просматривается только разработчиками приложений, вам не нужно создавать для него строковый ресурс.

 7. Посмотрите на свое приложение в предварительном просмотре. Отображается цифра "1".

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/3b33cbbc-f949-4cd9-b40d-a10b4b49f414)

 8. Запустите свое приложение. Вот как выглядит приложение при запуске на эмуляторе. "1" не отображается. Это правильное поведение.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/febca00c-4212-4f30-b87a-cc61462f533e)

Отлично, вы закончили с изменениями макета!

У вас есть приложение с кнопкой, но если вы нажмете на кнопку, ничего не произойдет. Чтобы изменить это, вам нужно написать некоторый код Kotlin, который бросает кости и обновляет экран при нажатии на кнопку.

Чтобы внести это изменение, вам нужно немного больше понимать структуру приложения для Android.

## 4. Введение в мероприятия

Activity предоставляет окно, в котором ваше приложение отображает свой пользовательский интерфейс. Как правило, Activity an занимает весь экран вашего запущенного приложения. У каждого приложения есть одно или несколько действий. Действие верхнего уровня, или первое действие, часто называется MainActivity и предоставляется шаблоном проекта. Например, когда пользователь прокручивает список приложений на своем устройстве и нажимает на значок приложения "Dice Roller", система Android запускает MainActivity это приложение.

В вашем MainActivity коде вам необходимо предоставить подробную информацию о макете Activity и о том, как пользователь должен взаимодействовать с ним.

 * В приложении для поздравительных открыток есть одно Activity, которое отображает сообщение о дне рождения и изображение.

 * В приложении Dice Roller есть одно, Activity которое отображает только что созданный вами TextView и Button макет.

Для более сложных приложений может быть несколько экрановActivity. У каждого Activity есть определенное назначение.

Например, в приложении "фотогалерея" у вас может быть одно Activity для отображения сетки фотографий, второе Activity для просмотра отдельной фотографии и третье Activity для редактирования отдельной фотографии.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/2735a552-cb34-41c8-a4aa-7ba2c2513956)

### Откройте файл MainActivity.kt

Вы добавите код для ответа на нажатие кнопки в MainActivity. Чтобы сделать это правильно, вам нужно больше узнать о MainActivity коде, который уже есть в вашем приложении.

 1. Перейдите к MainActivity.kt файлу и откройте его (app> java> com.example.diceroller > MainActivity.kt). Ниже приведено то, что вы должны увидеть. Если вы видите import..., нажмите на ..., чтобы развернуть импорт.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/10f7caca-5775-4d96-a1b3-98ef4142df4f)

Вам не обязательно понимать каждое слово приведенного выше кода, но вам необходимо иметь общее представление о том, что оно делает. Чем больше вы работаете с кодом Android, тем более знакомым он становится, и тем больше вы его понимаете.

 2. Посмотрите на код Kotlin для MainActivity класса, обозначенный ключевым словом class, а затем именем.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/e509c037-0267-47f7-94d3-3c444c8e4e77)

 3. Обратите внимание, что в вашем main() приложении нет MainActivity функции.

Ранее вы узнали, что каждая программа Kotlin должна иметь main() функцию. Приложения для Android работают по-разному. Вместо вызова main() функции система Android вызывает ваш onCreate() метод MainActivity при первом открытии вашего приложения.

 4. Найдите onCreate() метод, который выглядит как приведенный ниже код.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/97c6b53d-d9b7-48ec-9a66-bb0374ca8429)

Вы узнаете об override этом позже в codelab (так что пока не беспокойтесь об этом). Остальная часть onCreate() метода настраивает MainActivity, используя код из импорта и устанавливая начальный макет с помощью setContentView().

 5. Обратите внимание на строки, начинающиеся с import.

Android предоставляет фреймворк из многочисленных классов, упрощающий написание приложений для Android, но для этого необходимо точно знать, какой класс вы имеете в виду. Вы можете указать, какой класс фреймворка использовать в вашем коде, используя import инструкцию. Например, Button класс определен в android.widget.Button.

###cВключите автоматический импорт

Не забывать добавлять import инструкции при использовании большего количества классов может оказаться непросто. К счастью, Android Studio помогает вам выбирать правильный импорт при использовании классов, предоставляемых другими. На этом шаге вы настроите Android Studio на автоматическое добавление импорта, когда это возможно, и автоматическое удаление неиспользуемого импорта из вашего кода.

В macOS откройте настройки, перейдя в Файл> Настройки нового проекта> Настройки для новых проектов ... Разверните Другие настройки> Автоматический импорт. В разделах Java и Kotlin убедитесь, что установлены флажки Добавлять однозначный импорт "на лету" и Оптимизировать импорт "на лету" (для текущего проекта). Обратите внимание, что в каждом разделе есть два флажка. Сохраните изменения и закройте настройки, нажав OK.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/35830e63-5019-4c54-9fe7-f685c8da2a71)

В Windows откройте настройки, перейдя в Файл> Настройки> Редактор> Общие> Автоматический импорт. В разделах Java и Kotlin убедитесь, что установлены флажки Добавлять однозначный импорт "на лету" и Оптимизировать импорт "на лету" (для текущего проекта). Обратите внимание, что в каждом разделе есть два флажка. Сохраните изменения и закройте настройки, нажав OK.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/f6d10d35-ba07-44a9-bcd3-5dc1a184a1b9)

Однозначные настройки импорта позволяют Android Studio автоматически добавлять инструкцию import, если она может определить, какую из них использовать. Настройки оптимизации импорта позволяют Android Studio удалить любой импорт, который не используется вашим кодом.

## 5. Сделайте кнопку интерактивной

Теперь, когда вы знаете немного больше о MainActivity, вы измените приложение так, чтобы нажатие на Button вызывало какие-либо изменения на экране.

### При нажатии кнопки отображается сообщение

На этом шаге вы укажете, что при нажатии на кнопку в нижней части экрана отображается краткое сообщение.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/dacc9bd1-efad-414f-9c3a-0886fcc09d19)

 1. Добавьте следующий код в onCreate() метод после setContentView() вызова. findViewById() Метод находит Button в макете. R.id.button - идентификатор ресурса для Button, который является уникальным идентификатором для него.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/d9708705-983d-4dbe-ae32-253bf04abd1a)

---------------------------------------------------------------

Примечание: Android автоматически присваивает идентификационные номера ресурсам вашего приложения. Например, кнопка Roll имеет идентификатор ресурса, и строка для текста кнопки также имеет идентификатор ресурса. Идентификаторы ресурсов имеют вид R.<type>.<name>; например, R.string.roll. Для View идентификаторов <type> это id, например, R.id.button.

---------------------------------------------------------------

Код сохраняет ссылку на Button объект в вызываемой переменной rollButton, а не сам Button объект.

---------------------------------------------------------------

Важно: Когда Kotlin присваивает объект переменной, он не копирует объект целиком каждый раз, а сохраняет ссылку на объект. Вы можете придумать ссылку, похожую на национальный идентификационный номер; номер относится к человеку, но это не сам человек. Когда вы копируете номер, вы не копируете человека.

---------------------------------------------------------------

onCreate() Теперь метод должен выглядеть следующим образом:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/29c84f97-5c81-4f4a-b965-64358b3c1ee9)

 2. Убедитесь, что Android Studio автоматически добавила import инструкцию для Button. Обратите внимание, что теперь есть 3 инструкции импорта.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/aa9b4754-a16c-4ac8-be57-ecfdfabb2ebd)

---------------------------------------------------------------

Примечание: Если включение автоматического импорта не сработало, оно Button будет выделено красным. Вы можете вручную добавить правильный импорт, поместив текстовый курсор в словоButton, затем нажав Alt+Enter (Option+Enter на Mac).

---------------------------------------------------------------

Далее вам нужно связать код с Button, чтобы код мог выполняться при нажатии на Button. Прослушиватель кликов - это некоторый код для того, что делать, когда происходит нажатие. Вы можете думать об этом как о коде, который просто сидит, "слушая", как пользователь нажимает, в данном случае, на Button.

 3. Используйте rollButton объект и установите для него прослушиватель кликов, вызвав setOnClickListener() метод. Вместо круглых скобок, следующих за именем метода, вы фактически будете использовать фигурные скобки, следующие за именем метода. Это специальный синтаксис для объявления лямбда-выражения, о котором вы узнаете больше в будущей codelab.
 4. 
На данный момент вам нужно знать, что внутри фигурных скобок вы помещаете инструкции о том, что должно произойти при нажатии на кнопку. На следующем шаге ваше приложение отобразит всплывающее окно, представляющее собой краткое сообщение.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/236e39c9-7893-40cc-9d4e-806524f68982)

По мере ввода Android Studio может отображать несколько предложений. В этом случае выберите опцию setOnClickListener {...}.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/5cdd8b83-bb5c-402d-b9ec-5ed06b5db8d3)

В фигурных скобках вы помещаете инструкции о том, что должно произойти при нажатии на кнопку. На данный момент ваше приложение будет отображать Toast, которое представляет собой краткое сообщение, отображаемое пользователю.

 4. Создайте приложение Toast с текстом"Dice Rolled!", позвонив Toast.makeText().

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/fdf66663-3d22-4117-b3e2-df2ad1263afd)

 5. Затем попросите Toast отобразить себя, вызвав show() метод.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/3a643b96-c985-4407-bb44-22a47c5bed49)

Вот как выглядит ваш обновленный MainActivity класс; инструкции package and import по-прежнему находятся в верхней части файла:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/670e5ce5-331c-4593-aa8c-c8ecfdca8352)

Вы могли бы объединить две строки в прослушивателе кликов в одну строку без переменной. Это распространенный шаблон, который вы можете найти в другом коде.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/c74a59a8-0cdd-43f4-8153-fae134baf7f0)

 6. Запустите приложение и нажмите кнопку Roll. В нижней части экрана должно появиться всплывающее сообщение, которое через короткое время исчезнет.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/5815c6d2-8821-42a7-a2cd-dd662079ef92)

Ура! При нажатии кнопки появилось всплывающее сообщение! Вы впервые пишете код Kotlin для Android!

### Обновляйте текстовое представление при нажатии кнопки

Вместо отображения временного Toast сообщения вы напишете код для обновления TextView на экране при нажатии кнопки броска.

 1. Вернитесь к activity_main.xml (приложение > разрешение> макет>activity_main.xml)

 2. Нажмите на TextView.

 3. Обратите внимание, что идентификатором является TextView.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/07a16a00-6b44-4c30-981d-cb4b9e71d91a)

 4. Откройте MainActivity.kt (app> java> com.example.diceroller> MainActivity.kt)

 5. Удалите строки кода, которые создают и показываютToast.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/600f68a0-af0b-43a1-a49b-7d1c0170c5b9)

 6. Вместо них создайте новую переменную с именем resultTextView для хранения TextView.

 7. Используйте findViewById() для поиска textView в макете по его идентификатору и сохраните ссылку на него.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/13bf0a98-9aed-46bb-80a1-2801b4bf0ff2)

 8. Установите значение текста на resultTextView равным "6" в кавычках.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/8014f69e-3895-4058-8513-a74b710ef523)

Это похоже на то, что вы сделали, установив текст в атрибутах, но теперь это в вашем коде, поэтому текст должен быть заключен в двойные кавычки. Установка этого параметра явно означает, что на данный момент TextView всегда отображается 6. Вы добавите код для броска кости и отображения других значений в следующей задаче.

Вот как должен выглядеть MainActivity класс:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/fb6f673e-c7d5-4507-8b3d-c8a4a29934c9)

 9. Запустите приложение. Нажмите кнопку. Оно должно обновить TextView значение до "6".

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/be2eb8bd-fbd7-42ac-b033-b071b30f1128)

## 6. Добавьте логику броска костей

Единственное, чего не хватает, - это бросать кости. Вы можете повторно использовать Dice класс из предыдущей codelab, который обрабатывает логику для бросания кости.

### Добавьте класс Dice

 1. После последней фигурной скобки в MainActivity классе создайте Dice класс с roll() методом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/af7b844b-a42b-4e36-891a-48e8c5cf7fd6)

 2. Обратите внимание, что Android Studio может подчеркивать numSides волнистой серой линией. (Для появления этого может потребоваться некоторое время.)

 3. Наведите указатель мыши на numSides, и появится всплывающее окно с сообщением, что свойство ‘numSides' может быть закрытым.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/b1145912-3b99-46d7-aa86-14b57acacf32)

Пометка numSides как private сделает его доступным только в Dice классе. Поскольку единственный код, который будет использоваться, numSides находится внутри Dice класса, можно использовать этот аргумент private для Dice класса. Вы узнаете больше о private сравнении public переменных в следующем разделе.

 4. Продолжайте и внесите предложенное исправление в Android Studio, нажав Сделать ‘numSides' ‘приватным'.

### Создайте метод rollDice()

Теперь, когда вы добавили Dice класс в свое приложение, вы обновите MainActivity его, чтобы использовать. Чтобы лучше организовать свой код, поместите всю логику о броске кости в одну функцию.

 1. Замените код в прослушивателе кликов, который устанавливает текст равным "6", на вызов rollDice().

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/ee53c3ff-1c44-4f23-82a1-578a389a1433)

 2. Поскольку rollDice() оно еще не определено, Android Studio выдает ошибку и отображается rollDice() красным цветом.

 3. При наведении указателя на rollDice() Android Studio отображает проблему и некоторые возможные решения.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/a1d241c4-d5cb-49aa-b500-1c31f716b134)

 4. Нажмите на Дополнительные действия ... откроется меню. Android Studio предлагает выполнить больше работы за вас!

---------------------------------------------------------------

Совет: Если вам трудно навести указатель, а затем нажать на Дополнительные действия ... вы можете нажать на rollDice() и далее Alt+Enter (Option+Enter на Mac), чтобы вызвать меню.

---------------------------------------------------------------

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/198cf7eb-fac8-4073-b615-09e238eccb3c)

 5. Выберите Создать функцию ‘rollDice'. Android Studio создает пустое определение для функции внутри MainActivity.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/8afc9272-fe52-4205-b915-5afe998c056d)

### Создайте новый экземпляр объекта Dice

На этом шаге вы заставите rollDice() метод создать и бросить кости, а затем отобразите результат в TextView.

 1. Внутри rollDice() удалите TODO() вызов.

 2. Добавьте код для создания кости с 6 сторонами.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/21ef912a-d279-4bcb-b642-9490155ec799)

 3. Бросьте кости, вызвав roll() метод, и сохраните результат в переменной с именем diceRoll.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/dde4f259-bc38-4606-9c04-a51a1a90e543)

 4. Найдите приложение, TextView позвонив findViewById().

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/aac976ba-e012-4de8-83a1-5af7ab9ce286)

Переменная diceRoll представляет собой число, но TextView использует текст. Вы можете использовать toString() метод на diceRoll, чтобы преобразовать его в строку.

 5. Преобразуйте diceRoll в строку и используйте ее для обновления текста resultTextView.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/e02b1325-1f13-4bf8-8dc3-4c66245bea9f)

Вот как выглядит rollDice() метод:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/5ff9c36c-ad2d-42cc-aa95-ed9e1476fb61)

 6. Запустите свое приложение. Результат игры в кости должен измениться на другие значения, кроме 6! Поскольку это случайное число от 1 до 6, иногда может отображаться и значение 6.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/3076e440-9ef7-4c6d-a312-c6de0bc1f155)

Ура, ты молодец!

## 7. Внедряйте передовые методы кодирования

Обычно ваш код выглядит немного неаккуратно после того, как вы кое-где подправляете отдельные части, чтобы заставить ваше приложение работать. Но прежде чем вы уйдете от своего кода, вам следует выполнить несколько простых действий по очистке. Тогда приложение будет в хорошей форме, и его будет проще поддерживать в дальнейшем.

Именно эти привычки практикуют профессиональные разработчики Android при написании своего кода.

### Руководство по стилю Android

При командной работе членам команды идеально писать код аналогичным образом, чтобы обеспечить некоторую согласованность всего кода. Вот почему в Android есть руководство по стилю написания кода Android — соглашения об именовании, форматирование и другие рекомендации, которым следует следовать. При написании кода для Android соблюдайте эти рекомендации: Руководство по стилю Kotlin для разработчиков Android.

Ниже приведены несколько способов, которыми вы можете придерживаться руководства по стилю.

### Очистите свой код

#### Уплотните свой код

Вы можете сделать свой код более кратким, сократив его до меньшего количества строк. Например, вот код, который устанавливает прослушиватель кликов на Button.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/38b7ac4b-3be3-4f75-a6f8-26e6a31aeb1e)

Поскольку инструкции для прослушивателя кликов занимают всего 1 строку, вы можете свести rollDice() вызов метода и фигурные скобки в одну строку. Вот как это выглядит. Одна строка вместо трех строк!

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/85cee00e-ddeb-4850-85ca-a8f13b661ff0)

#### Переформатируйте свой код

Теперь вы переформатируете свой код, чтобы убедиться, что он соответствует рекомендуемым соглашениям о форматировании кода для Android.

 1. В MainActivity.kt классе выделите весь текст в файле с помощью сочетания клавиш Control+A в Windows (или Command+A на Mac). Или вы могли бы перейти в меню в Android Studio Правка> Выбрать все.

 2. Выделив весь текст в файле, перейдите в меню Android Studio Код> Переформатировать код или используйте сочетание клавиш Ctrl+Alt+L (или Command+Option+L на Mac).

Которое обновит форматирование вашего кода, включая пробелы, отступы и многое другое. Возможно, вы не увидите никаких изменений, и это хорошо. Тогда ваш код уже был правильно отформатирован!

### Прокомментируйте свой код

Добавьте несколько комментариев к своему коду, чтобы описать, что происходит в написанном вами коде. По мере усложнения кода также важно учитывать, почему вы написали код, который работает так, как вы это сделали. Если вы вернетесь к коду позже, чтобы внести изменения, что делает код, возможно, все еще будет понятно, но вы можете не вспомнить, почему написали его таким образом.

Обычно для каждого класса (MainActivity и Dice - единственные классы, которые есть в вашем приложении) и каждого метода, который вы пишете, добавляется комментарий. Используйте символы /** и */ в начале и конце вашего комментария, чтобы сообщить системе, что это не код. Эти строки будут проигнорированы, когда система выполнит ваш код.

Пример комментария к классу:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/af987ed3-0b4a-4642-adba-e6365ff5eb7e)

Пример комментария к методу:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/6fcb604d-1b77-43bc-b77e-2fc6c9494687)


В рамках метода вы можете добавлять комментарии, если это поможет читателю вашего кода. Напомним, что вы можете использовать // символ в начале своего комментария. Все, что находится после // символа в строке, считается комментарием.

Пример двух комментариев внутри метода:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/90411aa3-62ef-467a-b509-dad9a38e7852)

 1. Продолжайте и уделите некоторое время добавлению комментариев к вашему коду.

 2. Учитывая все эти изменения в комментариях и форматировании, рекомендуется повторно запустить ваше приложение, чтобы убедиться, что оно по-прежнему работает должным образом.

Смотрите код решения для одного из способов, которым вы могли бы прокомментировать свой код.

## 8. Код решения

Код решения для этой кодовой лаборатории находится в проекте и модуле, показанных ниже.

--------------------------------------------------------------

URL-адрес кода решения: https://github.com/google-developer-training/android-basics-kotlin-create-dice-roller-with-button-app-solution

--------------------------------------------------------------

Чтобы получить код для этой кодовой лаборатории и открыть ее в Android Studio, выполните следующие действия.

### Получите код

 1. Нажмите на предоставленный URL. Откроется страница проекта на GitHub в браузере.

 2. Проверьте и убедитесь, что название филиала совпадает с названием филиала, указанным в codelab. Например, на следующем скриншоте название филиала - main.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/77f97691-b003-42fc-ad8b-e7bc1c8001fa)

 3. На странице проекта в GitHub нажмите кнопку Code, которая вызовет всплывающее окно.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/48c1103c-849d-42c5-8ebf-c6f5d11cc58f)

 4. Во всплывающем окне нажмите кнопку Загрузить ZIP, чтобы сохранить проект на свой компьютер. Дождитесь завершения загрузки.

 5. Найдите файл на своем компьютере (скорее всего, в папке Downloads).

 6. Дважды щелкните ZIP-файл, чтобы распаковать его. При этом будет создана новая папка, содержащая файлы проекта.

### Откройте проект в Android Studio

 1. Запустите Android Studio.

 2. В окне Добро пожаловать в Android Studio нажмите Открыть.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/0e534eb4-3e66-4be1-8ee7-bf0b6c920da9)

Примечание: Если Android Studio уже открыта, вместо этого выберите пункт меню Файл> Открыть.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/16418208-13fa-4017-8940-a0dbccef9e62)

 3. В браузере файлов перейдите туда, где находится папка с распакованным проектом (скорее всего, в папке "Ваши загрузки").

 4. Дважды щелкните по папке этого проекта.

 5. Подождите, пока Android Studio откроет проект.

 6. Нажмите кнопку "Выполнить8de56cba7583251f.png", чтобы создать и запустить приложение. Убедитесь, что оно построено должным образом.

## 9. Краткие сведения

 * Добавьте Button в приложение для Android с помощью редактора макетов.

 * Измените MainActivity.kt класс, чтобы добавить интерактивное поведение в приложение.

 * В качестве временного решения отобразите Toast сообщение, чтобы убедиться, что вы на правильном пути.

 * Установите прослушиватель по щелчку для Button использования setOnClickListener() для добавления поведения при щелчке Button.

 * Когда приложение запущено, вы можете обновить экран, вызвав методы TextView, Button или другие элементы пользовательского интерфейса в макете.

 * Прокомментируйте свой код, чтобы помочь другим людям, которые читают ваш код, понять, в чем заключался ваш подход.

 * Переформатируйте свой код и очистите его.

# Добавить условное поведение в Kotlin

## 1. Прежде чем начать

В этой кодовой лаборатории Kotlin вы создадите еще одну игру в кости, Lucky Dice Roll, пытаясь выпадение счастливого числа. Ваша программа установит счастливое число и бросит кости. Затем вы сверяете выпавшее число со счастливым и выводите соответствующее сообщение на выходе. Чтобы выполнить это, вы узнаете, как сравнивать значения и принимать различные решения в вашей программе Kotlin.

Чтобы помочь вам сосредоточиться на концепциях программирования, не беспокоясь о пользовательском интерфейсе приложения, вы будете использовать браузерный инструмент программирования Kotlin и выводить свои результаты на консоль.

### Предварительные требования

 * Как открывать, редактировать и запускать код в https://developer.android.com/training/kotlinplayground

 * Возможность создавать и запускать программу Kotlin, которая использует переменные, функции с аргументами, классы с методами и выводит результат на консоль.

### Чему вы научитесь

 Как использовать инструкции if и else .

 Как сравнивать значения с помощью таких операторов, как больше (>), меньше (<) и равно (==).

 Как использовать when инструкции для выбора параметра на основе заданного значения.

 Что такое Boolean тип данных и как использовать его true и false значения для принятия решений.

### Что вы будете создавать

 * Игра в кости на основе Kotlin, Lucky Dice Roll, которая позволяет указать счастливое число. Игрок выиграет, если выпадет счастливое число.

### Что вам нужно

 * Компьютер с подключением к Интернету.


## 2. Принятие решений в вашем коде

Ваша программа Lucky Dice Roller должна определить, выпал ли пользователь счастливый номер и получает ли он поздравление или вместо этого получает сообщение с просьбой повторить попытку.

Как разработчику приложения, вам необходимо принимать решения о том, как должно вести себя приложение, и создавать различные результаты для ваших пользователей.

Если вы создаете приложение для покупок, вы можете показывать разные экраны в зависимости от выбранных пользователем вариантов доставки. В викторине вы бы показывали разные экраны в зависимости от того, правильный ли ответ дал игрок. В зависимости от приложения может быть много возможных результатов, которые вы захотите учесть в своем коде.

В вашей программе Lucky Dice Roller приложение должно обрабатывать различные случаи, такие как:

 * Если выпадет счастливое число, то отобразите поздравительное сообщение!

 * Иначе, если выпавшее число не является счастливым, отобразите сообщение с просьбой повторить попытку.
Чтобы добавить эту логику в свой код, используйте специальные ключевые слова Kotlin, такие как if и else и when.

Давайте рассмотрим несколько примеров.

### Используйте if инструкцию для настройки условия, которое выполняется

 1. Ознакомьтесь с приведенным ниже кодом. Можете ли вы догадаться, каким будет результат?

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/4af3086a-99a4-4a21-abfc-bb8079f761fc)

 2. Скопируйте и вставьте код в редактор программ Kotlin и запустите программу, чтобы просмотреть результат.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/dd485f91-4723-43f3-bb9d-2f24b79d975c)

Процесс принятия решений для этой программы является:

 1. Создайте переменную num и установите для нее значение 5 

 2. Если верно, что num больше 4, выведите "The variable is greater than 4".

 3. Во всех других ситуациях ничего не делайте.

В приведенном выше примере, num установлено значение 5. ifИнструкция сравнивает, если переменная больше 4. Поскольку это верно, система затем выполняет инструкции, заключенные в фигурные скобки, и печатает сообщение.

--------------------------------------------------------------

Резюме: > symbol - это оператор для сравнения двух значений, независимо от того, больше ли первое значение второго значения, и возврата результата true или false. Другими распространенными операторами являются: < для меньше, == для равно, >= для большего или равного и <= для меньшего или равного.

--------------------------------------------------------------

Обратите внимание на общие формата if заявление:

 * Начните с ключевого слова if .
 
 * Далее следуют две круглые скобки (). Внутри круглых скобок указано условие. Условием является все, что может быть true или false. Например, является ли число больше другого числа.

 * Заключите в две фигурные скобки {}. Внутри фигурных скобок вы помещаете код для выполнения, если условие равно true.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/76ae6e5f-8314-4493-b102-0016f11c9a2a)

--------------------------------------------------------------

### Логический тип данных для значений true и false:

 * Программа, проверяющая, выполнено ли условие, называется "оценкой условия". Результатом оценки условия является true если оно выполнено, или false если оно не выполнено. Разработчики также говорят: "условие оценивается как true" или "условие оценивается как false".

 * Условия могут оцениваться только для true или false.
 
 * Точно так же, как существует тип данных Int для целых чисел и IntRange для диапазонов, существует тип данных для true и false, называемый Boolean. Вы столкнетесь с Boolean переменными типа позже в этом курсе.

--------------------------------------------------------------

### Используйте if инструкцию для настройки условия, которое не выполняется

 1. Измените значение num на 3, как показано ниже. Что, по-вашему, произойдет, если вы запустите этот код?

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/d69778ed-4294-4b2e-8dd9-ff3576dfd158)

 2. Скопируйте и вставьте код в редактор программ Kotlin и запустите программу, чтобы увидеть пустой результат.

При num значении 3 ничего не печатается, потому что значение num меньше 4. Таким образом, условие, при котором num должно быть больше 4, равно false, и код, заключенный в фигурные скобки, не будет выполняться, и ничего не будет напечатано.

### Используйте else для создания альтернативы для неудачных условий

Вместо того, чтобы ничего не делать, вы можете предложить своим пользователям альтернативу, когда условие не выполняется. Так же, как и в обычном языке, вы можете сделать это с помощью инструкции else .

 1. Добавьте инструкцию else для печати сообщения, когда num не превышает 4, как показано ниже. Что, по-вашему, произойдет, если вы запустите этот код?

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/b852af85-e622-4cb3-83a0-28164f6dd755)

 2. Скопируйте и вставьте код в редактор программ Kotlin и запустите программу, чтобы просмотреть результат.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/1ff1f2c1-a6ab-4d8c-9203-cb5a12b90d4f)

 3. Обратите внимание, что когда num имеет значение 3, программа печатает сообщение "The variable is less than 4", связанное с оператором else , поскольку num не превышает 4.

 4. Измените num на 5 и запустите программу снова. Теперь верно, что num больше 4, и программа печатает "The variable is greater than 4".

 5. Измените num на 4 и запустите свою программу. Теперь 4 не больше 4, и программа печатает "The variable is less than 4".

Хотя "The variable is less than 4" является правильным выводом для условий, которые вы задаете в коде, этот напечатанный оператор неточен, поскольку 4 не меньше 4. Что вы можете сделать, так это добавить другое условие, которое проверяет наличие третьей возможности, то есть, точно ли num равно 4, и выводит правильное утверждение, когда это условие выполняется.

### Используйте комбинацию else if для добавления альтернативных условий

У вас может быть более одного условия. В вашем примере вот как вы можете охватить все возможности для num:

 * Если num больше 4, выведите "The variable is greater than 4".

 * Иначе, если num равно 4, выведите "The variable is equal to 4".

 * Ещё, распечатать "The variable is less than 4".

В инструкции if-else они называются разными случаями. В списке перечислены 3 случая.

Обновленный код выглядит следующим образом:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/ac28ecb9-18ad-4a35-8363-7a4ecde5d12c)

Обратите внимание на следующие изменения:

 * Значение num теперь равно 4, чтобы вы могли протестировать новое условие.

 * Между исходными операторами if и else находится новый оператор else if для случая, когда num равно ровно 4.

 1. Скопируйте и вставьте приведенный выше код в редактор программ Kotlin и запустите программу, чтобы просмотреть результат.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/a7273b7a-58b0-4c52-a09f-f6c093da754f)

 2. Поэкспериментируйте с изменением значения num и посмотрите, как это влияет на результат. Измените num на 2 и 6, чтобы вы могли видеть, как выполняются каждое из условий. true.

###Поток управления

Когда вы смотрите на приведенные выше инструкции if-else, код будет выполняться или протекать так, как управляется условиями. Таким образом, способ, которым вы управляете выполнением с помощью этих условий, называется "потоком управления" программой.

 * Допустим, ваш бросок кости num равен 3. Программа проверяет первое условие (num> 4). Это значение равно false, поэтому программа проверяет следующее условие (num == 4), которое также равно false. Затем программа выполняет код оператора else, который является окончательным вариантом.

 * Если число бросков костей равно 6, то первое условие (num> 4) выполняется. Программа печатает сообщение "The variable is greater than 4". Поскольку это условие истинно, оно не должно проверять остальные и выполняется с помощью оператора if-else .

 * Используйте комбинацию else + if для добавления альтернативных условий.

## 3. Создайте игру "Счастливый бросок костей"

В этом разделе, используя то, что вы узнали из предыдущего задания, вы обновите программу Dice Roller, чтобы проверить, выпало ли вам заранее установленное счастливое число. Если выпало, вы выигрываете!

### Настройте свой стартовый код

Вы запускаете Lucky Dice Roller с кодом, похожим на код решения предыдущей программы Kotlin Dice Roller. Вы можете отредактировать main() выполните соответствующую функцию в вашем предыдущем коде, или вы можете скопировать и вставить приведенный ниже код, чтобы начать работу.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/81d042bf-c085-47c3-8466-a4b51c537fde)

--------------------------------------------------------------

Примечание: Каждый раз, когда вы запускаете вышеупомянутую программу на игровой площадке, вызывается функция main() . При этом создается новый экземпляр Dice и вызывается roll() метод для него. Таким образом, каждый раз, когда вы запускаете программу, значение броска кубика может отличаться.

-------------------------------------------------------------

### Проверьте, выпало ли счастливое число

Сначала создайте счастливое число, а затем сравните бросок кости с этим числом.

 1. В main() удалите инструкцию println() .

 2. В main() добавьте val вызываемое luckyNumber и установите для него значение 4. Ваш код должен выглядеть следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/059caf7d-3e31-4350-974c-6afe822eaf37)

 3. Ниже добавьте оператор if с условием внутри круглых скобок () , которое проверяет, равно ли rollResult (==) luckyNumber. Оставьте немного места между фигурными скобками {} , чтобы вы могли добавить больше кода.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/5ab5d780-3a53-4e39-88a9-40e5dcea1280)

 4. Внутри фигурных скобок {} добавьте println инструкцию для печати "You win!"

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/5f49d839-c68a-4d5d-a255-bf9d93e1c52f)

 5. Запустите свою программу. Возможно, вам придется запустить ее несколько раз, прежде чем вам улыбнется удача и вы увидите сообщение о выигрыше в выходных данных!

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/b7d6bbb8-543f-4a32-ada3-3620362f8c46)

### Отвечать, если счастливое число не выпало

Отсутствие обратной связи от программы, если пользователь не выиграл, может заставить их задуматься, не сломана ли программа. Хорошей практикой является всегда предоставлять ответ, когда пользователь что-то делает. В программе Lucky Dice Roller вы можете сообщить игрокам, что они не выиграли, с помощью инструкции else .

 1. Добавить инструкцию else для печати "You didn't win, try again!".

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/f7a25d71-a79e-4ef0-bfd4-f8dc764db013)

 2. Запустите программу, и независимо от результата ваши пользователи всегда будут уведомлены.

На этом этапе пользователи знают, выиграли они или нет, но не почему. Всегда предоставляйте пользователям информацию, чтобы они понимали результат своих действий! Представьте, что ваша программа - это заявка на получение кредита. "Вы не получили одобрение, потому что у вас низкий кредитный рейтинг" - это намного более информативно, чем "Извините, вам не выдали кредит, попробуйте еще раз!" Для Lucky Dice Roller вы можете предоставлять пользователям разные информационные сообщения для каждого броска, если они проиграли. Для этого используйте несколько операторов else if .

 3. Добавить else if инструкции для печати разных сообщений для каждого рулона. При необходимости обратитесь к формату, который вы изучили в предыдущей задаче.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/7162acf7-345d-4777-86ab-45746df8ec45)

В приведенном выше коде вы

 * Проверить rollResult это luckyNumber.

 * Если значение rollResult равно значению luckyNumber, выведите сообщение о выигрыше.

 * В противном случае проверьте, равно ли значение rollResult 1, и если да, выведите сообщение о повторной попытке.

 * В противном случае проверьте, равно ли значение rollResult 2, и если да, выведите другое сообщение о повторной попытке.

 * В противном случае продолжайте проверять с помощью числа 5.

 * Если число не было ни одним из 1-5, остается единственный вариант - 6, поэтому нет необходимости в другом тестировании с помощью else if, и вы можете просто перехватить этот последний вариант с помощью оператора final else .

--------------------------------------------------------------

Совет: У вас может быть только один оператор if с одним оператором else в блоке кода if-else, но между ними у вас может быть столько операторов else if , сколько вам нужно.

--------------------------------------------------------------

Поскольку наличие нескольких else if вариантов очень распространено, у Kotlin есть более простой способ их написания.

### 4. Используйте оператор when

Тестирование для множества различных результатов или случаев очень распространено в программировании. Иногда список возможных результатов может быть очень длинным. Например, если вы бросаете 12-гранный кубик, у вас будет 11 else if операторы между успешным выполнением и окончательным else. Чтобы упростить написание и чтение такого рода инструкций, что помогает избежать ошибок, Kotlin предоставляет инструкцию when .

Вы собираетесь изменить свою программу, чтобы использовать инструкцию when . whenИнструкция начинается с ключевого слова when, за которым следуют круглые скобки (). Внутри круглых скобок находится значение для проверки. За ним следуют фигурные скобки {} чтобы код выполнялся при других условиях.

 1. В вашей программе в разделе main() выберите код от первого оператора if до фигурной скобки } , которая закрывает последний оператор else , и удалите его.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/92a74304-5ab3-44f1-865a-35a4294182ae)

 2. В main(), под объявлением luckyNumber, создайте оператор when . Поскольку вашему when необходимо протестировать свернутый результат, поместите rollResult между круглыми скобками (). Добавьте фигурные скобки {} с некоторым дополнительным интервалом, как показано ниже.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/3da8ce20-7944-402d-9bd6-f8e7b35325e5)

Как и раньше, сначала проверьте, rollResult совпадает ли оно с luckyNumber.

 1. Внутри фигурных скобок {} инструкции when добавьте инструкцию, которая проверяет rollResult на luckyNumber соответствие, и, если они совпадают, выведите сообщение о выигрыше. Инструкция выглядит следующим образом:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/8ebdfa42-50b4-47df-be13-1b1830ed11b1)

Это означает:

 * Сначала вы вводите значение, с которым сравниваете rollResult. Это luckyNumber.

 * Проследите за этим с помощью стрелки (->).

 * Затем добавьте действие, которое будет выполняться при наличии совпадения.

Прочтите это как "Если rollResult равно luckyNumber, то выведите сообщение "You win!" ".

И ваш main() код будет выглядеть примерно так.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/009bba9e-a342-4ec3-ba09-f01bbe14875b)

 2. Используйте тот же шаблон для добавления строк и сообщений для возможных бросков 1-6, за исключением 4, как показано ниже. Ваша готовая main() функция должна выглядеть следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/1d6f6831-7919-4b87-8ef3-6642c0cf35ef)

 3. Запустите свою программу. Разницы в выходных данных нет, но ваш код намного компактнее и его легче читать.

Поздравляем! Вы изучили два способа печати сообщений в зависимости от условия. Это мощный инструмент для написания интересных программ!

## 5. Краткие сведения
 * Используйте инструкцию if , чтобы задать условие для выполнения некоторых инструкций. Например, если пользователь выпал счастливый номер, выведите сообщение о выигрыше.

 * BooleanТип данных имеет значения true и false и может использоваться для принятия решений.

 * Сравните значения, используя такие операторы, как больше (>), меньше (<) и равно (==).

 * Используйте цепочку операторов else if для задания нескольких условий. Например, выведите разное сообщение для каждого возможного броска кости.
 
 * Используйте оператор else в конце цепочки условий, чтобы отслеживать любые случаи, которые могут быть не охвачены явно. Если вы охватываете случаи для 6-стороннего кубика, else оператор будет перехватывать числа 7 и 8, выпавшие с помощью 8-стороннего кубика.
 
 * Используйте инструкцию when как компактную форму выполнения кода, основанную на сравнении значения.

### Общая форма if-else:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/7a0fcf5d-9143-46ae-8b06-21bb89a6a3e6)

### Оператор When:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/cebe3f2b-e66e-42ff-a4dd-dfe7e7898755)

## Добавление изображений в приложение Dice Roller

### 1. Прежде чем начать

В этой кодовой лаборатории вы добавите изображения dice в существующее приложение Dice Roller для Android. Сначала обязательно заполните предыдущую кодовую лабораторию по созданию основы приложения Dice Roller.

Вместо отображения значения броска кости в a TextView ваше приложение отобразит соответствующее изображение кости с указанием количества выпавших сторон. Это сделает ваше приложение более наглядным и улучшит пользовательский интерфейс.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/21cfce4c-4af6-48cd-9264-fb6800bef822)

Вам будет предоставлена ссылка для загрузки изображений dice, и вы добавите их в качестве ресурсов в свое приложение. Чтобы написать код, для которого использовать изображение dice, вы будете использовать when инструкцию в Kotlin.

### Предварительные требования

 * Завершена работа над кодовой таблицей "Создать интерактивное приложение Dice Roller".

 * Возможность написания инструкций потока управления (if / else, when statements).

 * Возможность обновления пользовательского интерфейса приложения на основе пользовательского ввода (изменение MainActivity.kt файла).

 * Возможность добавления прослушивателя кликов в Button.

 * Возможность добавления ресурсов изображений в приложение для Android.

### Чему вы научитесь

 Как обновить ImageView во время работы приложения.

 Как настроить поведение вашего приложения в зависимости от различных условий (с помощью when инструкции).

### Что вы создадите

 *Приложение Dice Roller для Android, в котором есть Button возможность бросать кости и обновлять изображение на экране.

### Что вам нужно

 * На компьютере установлена Android Studio.

 * Подключение к Интернету для загрузки изображений Dice.

## 2. Обновите макет приложения

В этой задаче вы замените TextView в своем макете изображениеImageView, отображающее результат броска кости.

### Откройте приложение Dice Roller

 1. Откройте и запустите приложение Dice Roller из предыдущей codelab в Android Studio. Вы можете использовать код решения или созданный вами код.

Приложение должно выглядеть примерно так.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/d4698f5d-b28e-408b-bf23-6e84855b81d1)

 2. Откройте activity_main.xml (приложение> разрешение> макет > activity_main.xml ). Откроется редактор макетов.

### Удаление текстового представления

 1. В редакторе макетов выберите изображение TextView в дереве компонентов.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/62c450c7-97c3-440c-9799-82419cfe1644)

--------------------------------------------------------------

Совет: По мере добавления новых компонентов пользовательского интерфейса и удаления ограничений вы можете временно обнаружить, что они View перекрывают друг друга, что затрудняет выбор того, что находится сзади. В этом случае вы можете выбрать изображение, View выбрав его вместо этого в дереве компонентов.

--------------------------------------------------------------

 2. Щелкните правой кнопкой мыши и выберите Удалить или нажмите Delete клавишу.

 3. Пока игнорируйте предупреждение на Button. Вы исправите это на следующем шаге.

### Добавьте изображение в макет

 1. Перетащите изображение ImageView из палитры в вид Дизайна, расположив его над Button.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/355319cc-e34d-4ef5-b508-487df6096c87)

 2. В диалоговом окне "Выбор ресурса" выберите аватары в разделе "Образцы данных". Это временное изображение, которое вы будете использовать до тех пор, пока не добавите изображения кубиков в следующем задании.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/9565838a-f67a-420f-9f4b-d102e0179424)

 3. Нажмите OK. Дизайн вашего приложения должен выглядеть следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/db3d67a8-60aa-4de1-87ce-4a0028c8d904)

 4. В дереве компонентов вы заметите две ошибки. Button Не ограничено по вертикали, и ImageView не ограничено ни по вертикали, ни по горизонтали.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/ac56b1ad-504b-401f-9166-00a46ed42d5e)

Изображение Button не ограничено по вертикали, потому что вы удалили изображение, TextView под которым оно было изначально расположено. Теперь вам нужно расположить ImageView и Button под ним.

### Расположите изображение и кнопку

Вам нужно расположить их по вертикали ImageView на экране, независимо от того, где они Button расположены.

 1. Добавьте горизонтальные ограничения для ImageView. Соедините левую сторону ImageView с левым краем родительского изображения ConstraintLayout.

 2. Соедините правую сторону ImageView с правым краем родительского изображения. Это позволит расположить изображение по горизонтали ImageView внутри родительского изображения.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/87a2c5f0-548a-47a8-93db-6b6303b0716e)

 3. Добавьте вертикальное ограничение для ImageView, соединяющее верхнюю часть ImageView с верхней частью родительского изображения. Изображение ImageView будет скользить вверх до верхней части ConstraintLayout.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/ed7e6834-7462-41e9-8771-128ee3035643)

 4. Добавьте вертикальное ограничение для Button, соединяющее верхнюю часть Button с нижней ImageView. Button Будет скользить вверх под ImageView.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/94308fa5-9a3a-4866-97c1-e1bf530ca363)

 5. Теперь ImageView снова выберите изображение и добавьте вертикальное ограничение, соединяющее нижнюю часть ImageView с нижней частью родительского изображения. Это позволит расположить изображение ImageView вертикально в ConstraintLayout.

Теперь все предупреждения об ограничениях должны исчезнуть.

После всего этого вид дизайна должен выглядеть следующим образом: ImageView в центре и Button чуть ниже.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/d93e9b90-bbac-49d7-b1ee-96c0f9170a34)

Вы можете заметить предупреждение на ImageView в дереве компонентов, в котором предлагается добавить описание содержимого в ваше ImageView. Пока не беспокойтесь об этом предупреждении, потому что позже в codelab вы будете настраивать описание содержимого ImageView в зависимости от того, какое изображение dice вы показываете. Это изменение будет внесено в код Kotlin.

## 3. Добавляйте изображения в Dice Roller

В этой задаче вы загрузите несколько изображений dice и добавите их в свое приложение.

### Загружайте изображения dice

 1. Откройте этот URL, чтобы загрузить zip-файл с изображениями dice на свой компьютер. Дождитесь завершения загрузки.

 2. Найдите файл на своем компьютере (скорее всего, в папке "Загрузки").

 3. Дважды щелкните zip-файл, чтобы распаковать его. При этом будет создана новая dice_images папка, содержащая 6 файлов изображений dice, в которых отображаются значения dice от 1 до 6.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/7f4df0b8-5e6a-4a59-b118-9293094957c4)

### Добавляйте изображения dice в свое приложение

 1. В Android Studio выберите в меню Вид> Окна инструментов> Диспетчер ресурсов или перейдите на вкладку Менеджер ресурсов слева от окна Проекта.

 2. Нажмите + ниже Resource Manager и выберите Импортировать чертежи. Откроется файловый браузер.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/cf990865-90f8-4be3-b4d4-63580924d404)

 3. Найдите и выберите 6 файлов изображений dice. Вы можете выбрать первый файл, затем, удерживая нажатой клавишу Shift, выбрать другие файлы.

 4. Нажмите Открыть.

 5. Нажмите Далее, а затем Импортировать, чтобы подтвердить, что вы хотите импортировать эти 6 ресурсов.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/39201ade-2441-41a3-b2ca-6189546289c3)

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/9a7263b6-d686-4824-8619-d63eb4745b86)

 6. Если файлы были успешно импортированы, 6 изображений должны появиться в диспетчере ресурсов (приложение> разрешение> возможность рисования) для вашего приложения.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/c1288b7b-d7ca-47f9-b8cb-3de4aa0f38c5)

Отличная работа! В следующем задании вы будете использовать эти изображения в своем приложении.

Важно! - Вы сможете ссылаться на эти изображения в своем коде Kotlin, указывая их идентификаторы ресурсов:

 * R.drawable.dice_1
 * R.drawable.dice_2
 * R.drawable.dice_3
 * R.drawable.dice_4
 * R.drawable.dice_5
 * R.drawable.dice_6

## 4. Используйте изображения dice

### Замените образец изображения аватара

 1. В редакторе дизайна выберите ImageView.

 2. В разделе Атрибуты в Объявленных атрибутах найдите атрибут инструмента srcCompat, который устанавливается для изображения аватара.

Помните, что атрибут tools srcCompat использует предоставленное изображение только в режиме Дизайна Android Studio. Изображение отображается разработчикам только при создании приложения, но не будет видно при фактическом запуске приложения на эмуляторе или устройстве.

 3. Нажмите на крошечный предварительный просмотр аватара. Откроется диалоговое окно, в котором можно выбрать новый ресурс для этого ImageView.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/99d61f9b-1ecd-4576-8f6a-f31894b030a9)

 4. Выберите изображение, которое можно dice_1 нарисовать, и нажмите OK.

Вау! ImageView Занимает весь экран.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/00c85264-7487-487a-b147-d0c989f0621c)

Далее вы отрегулируете ширину и высоту изображения ImageView, чтобы оно не скрывало Button.

 5. В окне Атрибутов под виджетом Ограничений найдите атрибуты layout_width и layout_height. В настоящее время для них установлено значение wrap_content, что ImageView означает, что они будут такими же высокими и широкими, как содержимое (исходное изображение) внутри них.

 6. Вместо этого установите фиксированную ширину 160dp и фиксированную высоту 200dp на ImageView. Нажмите Enter.

Теперь оно ImageView стало намного меньше.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/a16a552a-670b-4379-821c-7393729d9f61)

Вы можете обнаружить, что Button слишком близко к изображению.

 7. Добавьте верхнее поле для кнопки с разрешением 16dp, установив его в виджете ограничений.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/53090744-2404-493b-b109-2f3984596762)

После обновления дизайна view приложение выглядит намного лучше!

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/70ae7937-65ab-4a5f-abf5-97626ad6dcd7)

--------------------------------------------------------------

Примечание: Используйте пиксели, не зависящие от плотности (dp), в качестве единицы измерения для определения этих размеров, чтобы размер изображения соответствующим образом масштабировался на устройствах с разным разрешением пикселей.

--------------------------------------------------------------

### Измените изображение кости при нажатии кнопки

Макет исправлен, но MainActivity класс необходимо обновить, чтобы использовать изображения dice.

В настоящее время в MainActivity.kt файле приложения имеется ошибка. Если вы попытаетесь запустить приложение, вы увидите эту ошибку сборки:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/a7094adb-35e3-4292-a82c-7bcb2a452a7b)

Это связано с тем, что ваш код по-прежнему ссылается на TextView, который вы удалили из макета.

 1. Откройте MainActivity.kt (app> java> com.example.diceroller > MainActivity.kt)

Код ссылается на R.id.textView, но Android Studio его не распознает.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/6bf15a3e-b879-4576-abb0-aa88f2799c5c)

 2. В рамках rollDice() метода выберите любой код, который ссылается на TextView, и удалите его.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/1642e2af-0c2d-4750-92c8-a56f0147b081)

 3. Все еще внутри rollDice() создайте новую переменную с именем diceImage типа ImageView. Установите ее равной ImageView из макета. Используйте findViewById() метод и передайте идентификатор ресурса для ImageView, R.id.imageView в качестве входного аргумента.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/30dd53ea-3e5d-4616-8e31-230e06e10009)

Если вам интересно, как определить точный идентификатор ресурса ImageView, проверьте id в верхней части окна Атрибутов.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/f4084794-80ec-4185-9301-3ee4b7756005)

Когда вы ссылаетесь на этот идентификатор ресурса в коде Kotlin, убедитесь, что вы вводите его точно так же (строчная буква i, заглавная буква V, без пробелов). В противном случае Android Studio выдаст сообщение об ошибке.

 4. Добавьте эту строку кода, чтобы проверить, что вы можете корректно обновлять ImageView при нажатии кнопки. Бросок кости не всегда будет равен "2", а просто используйте dice_2 изображение в целях тестирования.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/7ebf8b6b-5524-4234-becb-17710ddc7aec)

Этот код вызывает setImageResource() метод в ImageView, передавая идентификатор ресурса для dice_2 изображения. Это обновит ImageView экран для отображения dice_2 изображения.

Теперь метод rollDice () должен выглядеть следующим образом:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/9b2d5fe3-88fe-4378-ab4e-1105c6e006d4)

 5. Запустите свое приложение, чтобы убедиться, что оно работает без ошибок. Приложение должно запускаться с пустым экраном, за исключением кнопки Roll.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/ef6b94a8-073d-482f-b55e-80f6b3047375)

Как только вы нажмете на кнопку, появится изображение кости со значением 2. Да!!

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/4c884524-36fc-4cb5-aea8-6d797836550f)

Вы смогли изменить изображение одним нажатием кнопки! Вы становитесь ближе!

## 5. Отображение правильного изображения кости на основе броска кости

Очевидно, что результат игры в кости не всегда будет равен 2. Используйте логику потока управления, которую вы изучили в кодовой лаборатории Добавление условного поведения для разных бросков кубиков, чтобы соответствующее изображение кубика отображалось на экране в зависимости от случайного броска кубиков.

Прежде чем начать вводить код, концептуально подумайте о том, как должно вести себя приложение, написав некоторый псевдокод, описывающий, что должно произойти. Например:

Если пользователь выбросит 1, отобразите dice_1 изображение.

Если пользователь выбросит 2, отобразите dice_2 изображение.

и т.д...

---------------------------------------------------------------

ПсевдокодПримечание: это неофициальное описание того, как может работать некоторый код. В нем используются некоторые элементы компьютерного языка, такие как if / else, но описываются вещи понятным для человека способом. Это может быть полезно для планирования правильного подхода, прежде чем будут решены все детали.

---------------------------------------------------------------

Приведенный выше псевдокод может быть записан с помощью if / else операторов в Kotlin на основе значения броска кости.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/0dea2bd2-a938-4d0f-96c9-982a00d33f00)

Однако написание if / else для каждого случая становится довольно повторяющимся. Ту же логику можно выразить проще с помощью when инструкции. Это более лаконично (меньше кода)! Используйте этот подход в своем приложении.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/88a37dd7-b810-42ef-a4d1-e3c653c8fc01)

### Обновите метод rollDice ()

 1. В rollDice() методе каждый раз удаляйте строку кода, которая присваивает идентификатору ресурса изображения значение dice_2 image.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/b9ebf2dc-dcdb-4e78-a09d-092bccb4aff5)

Замените его на when инструкцию, которая обновляет изображение ImageView на основе diceRoll значения.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/44b93c05-b23d-43e8-b789-ef1bbdc409a3)

rollDice() Метод должен выглядеть следующим образом, когда вы закончите вносить изменения.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/732f4e54-a310-4293-85b3-c78fcfac7798)

 3. Запустите приложение. Нажатие кнопки Roll изменяет изображение кости на другие значения, кроме 2. Это работает!
ec209952f84b81bd.png 

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/879ce795-c37e-41a9-a7a9-4f296f8a0320)
![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/d37f8a31-b752-4368-b899-5752ffcc965c)

### Оптимизируйте свой код

Если вы хотите написать еще более лаконичный код, вы можете внести следующее изменение в код. Это не окажет никакого видимого влияния на пользователя вашего приложения, но сделает ваш код короче и менее повторяющимся.

Возможно, вы заметили, что вызов to diceImage.setImageResource()появляется 6 раз в вашем операторе when.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/72ab300b-061b-4a07-b929-128e6440111c)

Единственное, что меняется в каждом конкретном случае, - это идентификатор используемого ресурса. Это означает, что вы можете создать переменную для хранения идентификатора используемого ресурса. Затем вы можете вызвать diceImage.setImageResource()только один раз в своем коде и ввести правильный идентификатор ресурса.

 1. Замените приведенный выше код следующим.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/36264cee-36d2-4013-bf8a-87bd48157b9b)

Новая концепция здесь заключается в том, что when выражение действительно может возвращать значение. С этим новым фрагментом кода when выражение возвращает правильный идентификатор ресурса, который будет сохранен в drawableResource переменной. Затем вы можете использовать эту переменную для обновления отображаемого ресурса изображения.

 2. Обратите внимание, что when теперь это подчеркнуто красным. Если вы наведете на него указатель мыши, то увидите сообщение об ошибке: выражение ‘when' должно быть исчерпывающим, добавьте необходимую ветку ‘else'.

Ошибка заключается в том, что значение when выражения присваивается drawableResource, поэтому when оно должно быть исчерпывающим — оно должно обрабатывать все возможные случаи, чтобы значение всегда возвращалось, даже если вы выберете 12-сторонний кубик. Android Studio предлагает добавить else ветку. Вы можете исправить это, изменив регистр для 6 на else. Варианты для 1 through 5 те же, но все остальные, включая 6обрабатываются else.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/3d188f74-b2ba-4c31-a1dc-e30d0e82ae69)

 3. Запустите приложение, чтобы убедиться, что оно по-прежнему работает правильно. Обязательно протестируйте его достаточно, чтобы убедиться, что все цифры отображаются на изображениях кубиков с 1 по 6.

### Установите соответствующее описание содержимого в ImageView

Теперь, когда вы заменили выпавшее число изображением, программы чтения с экрана больше не могут определить, какое число было выпавшее. Чтобы исправить это, после обновления ресурса изображений обновите описание содержимого ImageView. Описание содержимого должно быть текстовым описанием того, что показано в ImageView, чтобы программы чтения с экрана могли это описать.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/2d6f07a9-bb58-43a4-9a49-3307159c8f06)

Программы чтения с экрана могут читать вслух это описание содержимого, поэтому, если на экране отображается изображение "6", описание содержимого будет прочитано вслух как "6".

--------------------------------------------------------------

Примечание: Обычно в описании контента должны использоваться строковые ресурсы, которые можно перевести на другие языки, но мы рассмотрим это в следующем уроке.

-------------------------------------------------------------

## 6. Внедряйте передовые методы кодирования

### Сделайте запуск более полезным

Когда пользователь открывает приложение в первый раз, оно остается пустым (за исключением кнопки Roll), что выглядит странно. Пользователи могут не знать, чего ожидать, поэтому измените пользовательский интерфейс таким образом, чтобы при первом запуске приложения отображался случайный бросок кости и создавалось Activity. Тогда пользователи с большей вероятностью поймут, что нажатие кнопки "Бросить" приведет к броску кости.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/2d55daac-01bf-4da3-b048-b8088c8a4913)

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/088858fd-9445-4870-a606-d741bdc9eb18)

### Прокомментируйте свой код

Добавьте несколько комментариев к своему коду, чтобы описать, что происходит в написанном вами коде.

После внесения всех этих изменений ваш rollDice() метод может выглядеть следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/d779a44a-f955-4793-bb00-e9c9c0867133)

Полный MainActivity.kt файл смотрите в коде решения на GitHub, ссылка на который приведена на следующем шаге.

Отличная работа по созданию приложения Dice Roller! Теперь вы можете принести это приложение на следующий игровой вечер со своими друзьями!

## 8. Краткие сведения

 * Используется setImageResource() для изменения изображения, отображаемого в ImageView

 * Используйте инструкции потока управления, такие как if / else выражения или when expressions для обработки различных случаев в вашем приложении, например, для отображения разных изображений при разных обстоятельствах.

# 5. Написание модульных тестов

## 1. Что вам понадобится

В предыдущих codelabs вы узнали, как создать проект с помощью Android Studio, модифицировать XML для создания пользовательского интерфейса для вашего приложения и модифицировать бизнес-логику для добавления функциональности. Эта кодовая лаборатория посвящена тому, почему тестирование важно, и расширяет возможности модульных тестов. Вы получаете возможность увидеть, как они выглядят и как их писать.

### Предварительные требования

 * Вы создали проект в Android Studio.

 * У вас есть некоторый опыт написания кода в Android Studio.

### Чему вы научитесь

 Почему тестирование важно.

 Как выглядят модульные тесты.

 Как писать и запускать модульные тесты.

### Что вам понадобится

 * Компьютер с установленной Android Studio.

 * Проект, который вы создали в предыдущей codelab по этому пути.

## 2. Введение

Теперь, когда вы написали некоторый код для Android, самое время поработать с тестовым кодом. Сначала вы изучаете некоторую философию тестирования, затем углубляетесь в автоматически созданные тесты в Android-проекте и, наконец, пишете свои собственные тесты для приложения Dice Roller! В этом уроке рассматривается много материала, но не пугайтесь! Не торопитесь с этим материалом, потому что тестирование занимает много времени и требует большой практики. Не расстраивайтесь, если у вас не получится разобраться с этим сразу.

### Почему тестирование важно?

Сначала может показаться, что вам на самом деле не нужны тесты в вашем приложении. Когда ваше приложение маленькое и имеет ограниченную функциональность, его легко протестировать вручную и определить, все ли работает правильно. Однако по мере роста вашего приложения ручное тестирование требует гораздо больше усилий, чем написание автоматических тестов. Более того, как только вы начинаете работать над приложениями профессионального уровня, тестирование становится критичным, когда у вас большая база пользователей. Вы должны учитывать множество различных типов устройств, работающих под управлением множества разных версий Android. В конечном итоге вы достигнете точки, когда автоматизированные тесты смогут учитывать большинство сценариев использования значительно быстрее, чем ручные тесты. Когда вы запускаете тесты перед выпуском нового кода, вы можете вносить изменения в существующий код, чтобы избежать выпуска приложения с неожиданным поведением. Помните, что автоматизированные тесты - это тесты, выполняемые с помощью программного обеспечения, в отличие от ручных тестов, которые выполняются человеком, непосредственно взаимодействующим с устройством. Автоматическое тестирование и ручное тестирование играют решающую роль в обеспечении приятного взаимодействия пользователей с вашим продуктом. Однако автоматизированные тесты могут быть более точными и они оптимизируют производительность вашей команды, поскольку от человека не требуется их выполнение, и они могут выполняться намного быстрее, чем ручное тестирование.

### Более пристальный взгляд на модульные тесты

В этой кодовой лаборатории основное внимание уделяется модульным тестам. Позже вы рассмотрите тесты инструментария. Для начала вы посмотрите на тесты, которые создаются при создании приложения для Android с помощью Android Studio. Вы также получите некоторый практический опыт выполнения тестов и познакомитесь с написанием тестового кода.

В предыдущем пути вы рассказали, где найти исходные файлы для тестов. Модульные тесты всегда находятся в test каталоге:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/fc401edc-f700-438a-8a89-54e355017f58)

 1. Откройте app/build.gradle файл и посмотрите на зависимости. Вы видите некоторые зависимости, помеченные как testImplementation и androidTestImplementation, которые соответствуют модульным и инструментальным тестам соответственно. Следует отметить, что:
app/build.gradle

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/647a9d3f-dd60-473a-b958-056343e3fdcc)

JUnit

 2. В test каталоге откройте ExampleUnitTest.kt файл.

Вы должны увидеть пример модульного теста, который выглядит следующим образом:

ExampleUnitTest.kt

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/a53cb06d-ccec-4f77-b2e5-06adce326b46)

Хотя вы добавили некоторый код в приложение Dice Roller, вы, скорее всего, не писали никаких тестов. Таким образом, нет ничего, кроме некоторого общего кода, который автоматически создается Android Studio. Это произвольный тест, который служит заполнителем для более релевантных тестов, которые, как ожидается, напишет разработчик. В настоящее время этот блок кода проверяет только то, что 2 + 2 = 4. Конечно, это всегда верно. Присмотритесь повнимательнее к тому, что происходит:

 * Сначала тестовые функции должны быть снабжены @ Test аннотациями, импортированными из org.junit.test библиотеки. Вы можете рассматривать аннотации как теги метаданных для фрагмента кода, которые могут изменить способ компиляции кода. В этом случае аннотация сообщает компилятору, что следующий метод является тестом, что позволяет ему выполняться как таковому.@Test

После аннотации у вас есть объявление функции, в данном случае addition_isCorrect()функции. Внутри функции assertEquals() функция утверждает, что ожидаемое значение должно равняться фактическому значению, полученному с помощью бизнес-логики. Методы утверждения являются конечной целью модульного теста. В конечном счете, вы хотите утверждать, что результат, полученный из вашего кода, находится в определенном состоянии. Если состояние результата соответствует ожидаемому состоянию, тест проходит. Если состояние результата не соответствует ожидаемому состоянию, тест завершается неудачей. В этом случае код сравнивает два значения, поэтому assertEquals() метод принимает два параметра — ожидаемое значение и фактическое значение. В соответствии со своим названием, ожидаемое значение - это то, каким вы ожидаете получить конкретный результат, в данном случае 4. Фактическое значение представляет результат фактического фрагмента кода. Обычно при этом тестируется фрагмент кода из самого приложения. В данном случае это всего лишь произвольный фрагмент кода, например, 2 + 2. Без лишних слов запустите этот тест, чтобы посмотреть, что получится.

-------------------------------------------------------------

В аннотации у вас есть объявление функции, в данном случае <wbr>функции. Внутри функции <wbr> функция утверждает, что ожидаемое значение должно равняться фактическому значению, полученному с помощью бизнес-логики. Методы утверждения являются конечной целью модульного теста. В конечном счете, вы хотите утверждать, что результат, полученный из вашего кода, находится в определенном состоянии. Если состояние результата соответствует ожидаемому состоянию, тест проходит. Если состояние результата не соответствует ожидаемому состоянию, тест завершается неудачей. В этом случае код сравнивает два значения, поэтому <wbr> метод принимает два параметра — ожидаемое значение и фактическое значение. В соответствии со своим названием, ожидаемое значение - это то, каким вы ожидаете получить конкретный результат, в данном случае 4. Фактическое значение представляет результат фактического фрагмента кода. Обычно при этом тестируется фрагмент кода из самого приложения. В данном случае это всего лишь произвольный фрагмент кода, например, <wbr>. Без лишних слов запустите этот тест, чтобы посмотреть, что получится.JUnit

 * assertEquals()

 * assertNotEquals()

 * assertThat()

 * assertTrue()

 * assertFalse()

 * assertNull()

 * assertNotNull()

For more information, see Assert.

--------------------------------------------------------------

Существует множество способов запуска тестов в Android Studio, о которых вы узнаете позже. Сейчас все просто.

 1. Рядом с объявлением addition_isCorrect метода щелкните стрелки, а затем выберите Выполнить ‘ExampleUnitTest.addition_isCorrect'.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/07eb57ea-efda-43dc-b0e5-05eec8d68bc5)

Это то, что называется положительным тестом. Другими словами, утверждение является утвердительным. 2 + 2 равно 4. В качестве альтернативы мы могли бы написать отрицательный тест, который выдает отрицательное утверждение. Например: 2 + 2 не равно 5.

В <strong>перспективе</strong> панели, вы должны увидеть что-то вроде этого скриншота:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/ac5ceda1-4ad5-4ac1-bfe6-d22f3b92ef68)

Существуют различные признаки успешного выполнения теста, а именно зеленые флажки и количество пройденных тестов.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/03b4bc75-b718-4cbe-877f-258977322a9c)

 2. Измените тест, чтобы увидеть, как выглядит сбой. Измените 2 + 2 на 2 + 3, затем выполните тест снова. Имейте в виду, что вы экспериментируете с сгенерированным кодом только для того, чтобы получить представление о том, как работают тесты. Эти изменения не имеют никакого отношения к функциональности Dice Roller.

ExampleUnitTest.kt

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/5e1eaef3-e57c-43ca-8f30-1d3c4f5fc1e6)

После того, как вы запустите остальные, вы должны увидеть что-то вроде этого скриншота:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/ac510bef-babc-4c4b-92a8-600fc4f95a87)

Красный текст указывает на сбой теста. В меню результатов тестирования при нажатии на пункты в появляется сообщение об ошибке, в котором указывается причина сбоя теста.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/f08f014e-05b9-4a48-a684-4ab700045376)

В этом случае сообщение указывает, что утверждение завершилось ошибкой, поскольку ожидался результат 4, но фактическое значение было 5. Это имеет смысл, потому что вы изменили фактическое значение на 2 + 3, но оставили ожидаемое значение равным 4. Вы также можете увидеть строку, на которой тест завершился неудачей. В данном случае это строка 15, обозначаемая как ExampleUnitTest.kt:15.

 3. Для большей тщательности измените ожидаемое значение с 4 на 5 и запустите тест снова. Теперь тест должен пройти успешно, поскольку ожидаемое значение соответствует фактическому результату рассматриваемого кода.

№№ 3. Напишите свой первый модульный тест

Теперь, когда вы немного освоились с модульными тестами, вы можете написать свой собственный модульный тест, который больше подходит для приложения Dice Roller.

Как вы уже заметили, основная функциональность приложения Dice Roller основана на генераторе случайных чисел. К сожалению, генераторы случайных чисел, как известно, сложно тестировать, потому что вы не можете быть уверены в результате случайно сгенерированного числа. Цель этого теста - убедиться, что когда вы бросаете кости или вызываете roll метод в dice классе, вы получаете обратно соответствующее число. Тест, который вы пишете, просто проверяет, что выходной сигнал генератора случайных чисел является числом в диапазоне, который вы указали генератору.

 1. В ExampleUnitTest.kt файле удалите сгенерированный метод тестирования и импортируйте инструкции. Теперь ваш файл должен выглядеть следующим образом:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/b08ce9cf-701e-4690-b406-b7dee0de67c3)

 2. Создание generates_number() функции:

ExampleUnitTest.kt

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/6064adb0-230d-42fc-a752-112add1c216b)

 3. Пометьте generates_number() метод @Test аннотацией. Обратите внимание, что при попытке вызова @Test текст выделяется красным цветом. Это связано с тем, что он не может найти объявление этой аннотации, поэтому вам нужно импортировать ее. Вы можете сделать это автоматически при нажатии Control+Enter (или Options+Return на Mac).

Если вы нажмете на строку кода, вы должны увидеть приглашение к импорту:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/f4815037-344a-47af-b0f2-9b754f37b8b9)

В качестве альтернативы вы также можете скопировать и вставить import org.junit.Test файл после имени пакета, но перед объявлением класса. Теперь код должен выглядеть следующим образом:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/fb2849b7-cd0d-4004-a394-7c49185b4233)

 4. Создайте экземпляр Dice объекта.

ExampleUnitTest.kt

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/1a984f26-8f2c-431c-b3e2-c570f3ef78ca)

 5. Затем вызовите roll() метод для этого экземпляра и сохраните возвращаемое значение.

ExampleUnitTest.kt

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/e9fb3437-63ea-4bad-b254-4fc4d0c1e7f0)

 6. Наконец, сделайте фактическое утверждение. Другими словами, вам нужно утверждать, что метод вернул значение, которое находится в пределах количества сторон, которые вы передали. Итак, в этом случае значение должно быть больше 0 и меньше 7. Для достижения этого используйте assertTrue() метод. Обратите внимание, что при попытке вызвать assertTrue()метод сначала текст становится красным. Это связано с тем, что он не может найти объявление этого метода, поэтому вам нужно импортировать его, аналогично тому, с чем вы столкнулись с аннотацией.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/578a1ee1-2ded-4c14-8b91-10a8d43ba0ed)

Вы можете автоматически импортировать его, как обсуждалось ранее. Однако обратите внимание, что на этот раз у вас есть несколько вариантов на выбор. В этом случае это должен быть вариант из org.junit.Assert пакета:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/c471d134-d5c9-4313-b9f0-27bf8b08e97d)

В качестве альтернативы вы можете вставить этот код после инструкции import для аннотации теста:

ExampleUnitTest.kt

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/a01bf960-7f0a-4cc9-8a26-9f497d049998)

Теперь ваш код выглядит следующим образом:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/9eb98843-7f56-403e-a7bd-855097b7067a)

Предыдущий шагControl+PCommand+P

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/499ad0ce-4c81-4470-b353-ef90ceca1267)

assertTrue()Метод принимает два параметра: a String и a Boolean. Если утверждение завершается ошибкой, строка представляет собой сообщение, которое отображается в консоли. Логическое значение является условным выражением. Установите сообщение в:

ExampleUnitTest.kt

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/10d525a6-52ec-4887-a3b6-3b0a48d82bff)

Как упоминалось ранее, тестирование случайных чисел является сложной задачей, поскольку значение числа невозможно предсказать из-за природы его случайности. Все, что можно сделать, это убедиться, что значение находится в определенном диапазоне. Установите параметр condition равным:

ExampleUnitTest.kt

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/f98dec42-eb8e-408f-8879-8c2c9b1a5f2d)

Код должен выглядеть примерно так:

ExampleUnitTest.kt

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/6b196d1a-d8c3-4cc0-8718-b3e083f615e9)

 7. Щелкните стрелки рядом с функцией и затем выберите Выполнить ‘ExampleUnitTest.generates_number()'.
Если ваш код похож на предыдущий фрагмент кода, ваш тест должен пройти успешно!

 8. Необязательно: для дополнительной практики измените кубик на 4- или 5-сторонний, не изменяя утверждение, чтобы увидеть, что тест завершается неудачей.

## 4. Поздравляем

Вы узнали:

 * Важность тестирования.

 * Как выглядит модульный тест.

 * Как запустить модульный тест.

 * Немного общего синтаксиса тестирования.

 * Как написать модульный тест.

# 6. Введение в отладку

## 1. Прежде чем вы начнете

Любой, кто пользовался каким-либо программным обеспечением, скорее всего, сталкивался с ошибкой. Ошибка - это ошибка в части программного обеспечения, которая вызывает непреднамеренное поведение, такое как сбой приложения или функция, работающая не так, как ожидалось. Все разработчики, независимо от опыта, допускают ошибки при написании кода, и одним из важнейших навыков разработчика Android является их выявление и исправление. Нередко можно увидеть целые выпуски приложений, посвященные исправлению ошибок. Например, смотрите подробную информацию о версии Google Maps ниже:

1. Прежде чем вы начнете
Любой, кто пользовался каким-либо программным обеспечением, скорее всего, сталкивался с ошибкой. Ошибка - это ошибка в части программного обеспечения, которая вызывает непреднамеренное поведение, такое как сбой приложения или функция, работающая не так, как ожидалось. Все разработчики, независимо от опыта, допускают ошибки при написании кода, и одним из важнейших навыков разработчика Android является их выявление и исправление. Нередко можно увидеть целые выпуски приложений, посвященные исправлению ошибок. Например, смотрите подробную информацию о версии Google Maps ниже:

Процесс исправления ошибок называется отладкой. Известный ученый-компьютерщик Брайан Керниган однажды сказал, что "самым эффективным инструментом отладки по-прежнему является тщательная проработка в сочетании с разумно размещенными инструкциями печати". Хотя вы, возможно, уже знакомы с инструкцией Kotlin println () из предыдущих codelabs, профессиональные разработчики Android используют ведение журнала для лучшей организации выходных данных своей программы. В этой кодовой лаборатории вы узнаете, как использовать ведение журнала в Android Studio и как его можно использовать в качестве инструмента отладки. Вы также научитесь читать журналы сообщений об ошибках, называемые трассировками стека, для выявления и устранения ошибок. Наконец, вы узнаете, как самостоятельно находить ошибки, а также узнаете, как вы можете записывать выходные данные из эмулятора Android в виде скриншота или GIF вашего запущенного приложения.

### Предварительные требования

Вы знаете, как управлять проектом в Android Studio.

#### Чему вы научитесь

 * К концу этой кодовой таблицы вы сможете

 * Записывайте журналы с помощью android.util.Logger.

 * Знайте, когда использовать разные уровни журнала.

 * Используйте журналы как простой и мощный инструмент отладки.

 * Как найти значимую информацию в трассировке стека.

 * Поиск сообщений об ошибках для устранения сбоев приложений.

 * Делайте скриншоты и анимированные GIF-файлы с помощью эмулятора Android.

### Что вам понадобится

 * Компьютер с установленной Android studio.

## 2. Создайте новый проект

Вместо того, чтобы использовать большое и сложное приложение, мы собираемся начать с пустого проекта, чтобы продемонстрировать инструкции журнала и их использование для отладки.

Начните с создания нового проекта Android Studio, как показано на рисунке.

 1. На экране "Новый проект" выберите "Пустое действие".

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/5328d3e2-c49b-4600-8f92-fead788b1341)

 2. Назовите приложение "Отладка". Убедитесь, что для языка установлен Kotlin, а все остальное оставьте без изменений.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/88e8af09-7384-4d33-80f5-7c45c0815513)

После создания проекта вы будете встречены новым проектом Android Studio, в котором будет показан файл с именем MainActivity.kt.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/0fe19b2f-8de6-4f50-8031-f3b91578dad8)

## 3. Протоколирование и отладочный вывод

В предыдущих уроках вы использовали println() инструкцию Kotlin для вывода текста. В приложении для Android наилучшей практикой для протоколирования выходных данных является использование класса Log. Существует несколько функций для протоколирования выходных данных, принимающих вид Log.v(), Log.d(), Log.i() Log.w(), Log.e()или,,. Эти методы принимают два параметра: первый, называемый "tag", представляет собой строку, идентифицирующую источник сообщения журнала (например, имя класса, который зарегистрировал текст). Второй - это само сообщение журнала.

Выполните следующие действия, чтобы начать использовать ведение журнала в вашем пустом проекте.

 1. В MainActivity.kt перед объявлением класса добавьте константу с именем TAG и установите ее значение в качестве имени класса, MainActivity.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/715ec895-8a95-4f1b-adc0-66717a2df414)

---------------------------------------------------------------

Примечание: тег log обычно объявляется вне класса. Хотя эта переменная объявлена за пределами MainActivity, она объявлена как закрытая, так что доступна будет только в MainActivity.kt. Это означает, что вы также можете объявить TAG переменную для других классов. Чтобы узнать больше, ознакомьтесь с документацией Kotlin о модификаторах видимости.

---------------------------------------------------------------

 2. Добавьте новую функцию в MainActivity класс, вызываемый logging(), как показано на рисунке.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/b5dfbb91-b6cb-45dc-a791-a2dc8ed5c841)

 3. Вызовите logging() in onCreate(). Новый onCreate() метод должен выглядеть следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/0d4e5fca-48dd-4415-9ab0-25cd054e25ca)

 4. Запустите приложение, чтобы увидеть журналы в действии. Журналы отображаются в окне Logcat в нижней части экрана. Поскольку Logcat будет отображать выходные данные других процессов на устройстве (или эмуляторе), вы можете выбрать свое приложение (com.example.debugging) из выпадающего меню, чтобы отфильтровать все журналы, которые не имеют отношения к вашему приложению.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/f9226c4d-9a9d-4b59-a5ac-f60b73dcf1ae)

В окне вывода вы должны увидеть свой вывод "Hello, world!" . При необходимости введите "hello" в поле поиска в верхней части окна Logcat, чтобы выполнить поиск по всем журналам.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/61b2ea85-2e24-4e75-9fd9-1480ed86ea94)

### Уровни регистрации

Причина, по которой существуют разные функции ведения журнала, названные разными буквами, заключается в том, что они соответствуют разным уровням ведения журнала. В зависимости от того, какой тип информации вы хотите выводить, вы должны использовать другой уровень журнала, который поможет вам фильтровать ее в Logcat выводе. Существует пять основных уровней журнала, которые вы будете использовать регулярно.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/5bf5d9af-a23f-4323-9afb-ff5182027f8a)

Имейте в виду, что не существует установленных правил для того, когда использовать каждый тип уровня журнала, особенно для того, когда использовать DEBUG и VERBOSE. Команды разработчиков программного обеспечения могут создавать свои собственные рекомендации относительно того, когда использовать каждый уровень журнала, или, возможно, решить вообще не использовать определенные уровни журнала, например . Важно помнить об этих двух уровнях ведения журнала, что они отсутствуют в сборках релизов, поэтому использование журналов для отладки не повлияет на производительность опубликованных приложений, тогда как VERBOSE инструкции остаются в сборках релизов и негативно влияют на производительность.println()

---------------------------------------------------------------

Забавный факт: на самом деле существует другой уровень регистрации, Log.wtf() (Какой ужасный сбой), который существует для регистрации событий, которые, вы уверены, никогда не произойдут, отсюда и название. Эти журналы имеют ASSERT уровень, уровень журнала выше ERROR.

---------------------------------------------------------------

Давайте посмотрим, как выглядят эти различные уровни ведения журнала в Logcat.

 1. В MainActivity.ktзамените содержимое logging() метода следующим.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/2281f016-f5e4-4c81-a3d5-8e59783f336f)

---------------------------------------------------------------

Примечание: тег log обычно объявляется вне класса. Хотя эта переменная объявлена за пределами MainActivity, она объявлена как закрытая, так что доступна будет только в MainActivity.kt. Это означает, что вы также можете объявить TAG переменную для других классов. Чтобы узнать больше, ознакомьтесь с документацией Kotlin о модификаторах видимости.

---------------------------------------------------------------

 2. Запустите свое приложение и просмотрите выходные данные в Logcat. При необходимости отфильтруйте выходные данные, чтобы показывать только журналы процесса com.example.debugging. Вы также можете отфильтровать выходные данные, чтобы показывать только журналы с тегом "MainActivity". Для этого выберите Изменить конфигурацию фильтра в выпадающем меню в правом верхнем углу окна Logcat.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/c52dbb88-bdfd-4548-a3bb-d36ba8cc955a)

 3. Затем введите "MainActivity" для тега журнала и создайте имя для вашего фильтра, как показано на рисунке.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/40dc0833-536b-4f16-a03a-b6d77edcd62c)

 4. Теперь вы должны видеть только сообщения журнала с тегом "MainActivity".

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/f477ea2b-626a-4def-8dca-77485439415a)

Обратите внимание, что перед именем класса стоит буква, например, W/MainActivity, соответствующая уровню журнала. Кроме того, WARN журнал отображается синим цветом, тогда как ERROR журнал отображается красным, точно так же, как фатальная ошибка в предыдущем примере.

 5. Точно так же, как вы можете фильтровать выходные данные отладки по процессу, вы также можете фильтровать выходные данные по уровню журнала. По умолчанию для этого параметра установлено значение Verbose, при котором будут отображаться VERBOSE журналы и более высокие уровни журнала. Выберите Warn из выпадающего меню и обратите внимание, что теперь отображаются только WARN и ERROR журналы уровней.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/9760687a-1e07-4891-a05f-451bfd0a703e)

 6. Опять же, измените выпадающий список на Assert и обратите внимание, что журналы не отображаются. Это отфильтровывает все, что находится на ERROR уровне и ниже.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/853a08bb-c011-42e6-bce5-d354d8a9ad0b)

Хотя может показаться, что вы слишком серьезно относитесь к println() заявлениям, по мере создания более крупных приложений будет намного больше выходных данных Logcat, а использование разных уровней ведения журнала позволит вам выбрать наиболее полезную и релевантную информацию. Использование журнала считается лучшей практикой и предпочтительнее, чем println() при разработке Android, поскольку журналы отладки и подробные описания не влияют на производительность при сборке релизов. Вы также можете фильтровать журналы на основе разных уровней журнала. Выбор правильного уровня ведения журнала принесет пользу другим членам вашей команды разработчиков, которые, возможно, не так хорошо знакомы с кодом, как вы, и значительно упростит выявление и устранение ошибок.

## 4. Журналы с сообщениями об ошибках

### Исправлена ошибка

В пустом проекте не так уж много работы по отладке. Многие ошибки, с которыми вы столкнетесь как разработчик Android, связаны со сбоями приложений, что, очевидно, не очень удобно для пользователя. Давайте добавим некоторый код, который вызывает сбой этого приложения.

Возможно, вы помните, что на уроке математики вас учили, что число нельзя разделить на ноль. Давайте посмотрим, что происходит, когда мы пытаемся разделить на ноль в коде.

 1. Добавьте следующую функцию к вашей MainActivity.kt функции над logging(). Этот код начинается с двух чисел и используется repeat для регистрации результата пятикратного деления числителя на знаменатель. Каждый раз, когда выполняется код в repeat блоке, значение знаменателя уменьшается на единицу. На пятой и последней итерации приложение пытается разделить на ноль.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/d3573d92-79eb-4ea9-a952-303b4526f5f0)

 2. После вызова logging() in onCreate() добавьте вызов division() функции.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/96f8cf19-7262-4b99-bb11-73531f5c8616)
 
 3. Запустите свое приложение еще раз и обратите внимание, что оно выходит из строя. Если вы прокрутите вниз до журналов из вашего MainActivity.kt класса, вы увидите журналы из logging() функции, которые вы определили ранее, подробные журналы из division() функции, а затем красный журнал ошибок, объясняющий причину сбоя приложения.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/2ecaafbe-1f41-4cd5-ac21-98e712d16c98)

--------------------------------------------------------------

Предупреждение: Поскольку они удалены из релизных сборок, вам следует избегать введения побочных эффектов (изменения значений в вашем коде) из инструкций журнала. Например, если вы изменили приведенный выше пример, чтобы уменьшить знаменатель в инструкции log, как в Log.v(TAG, "${numerator / denominator--}"), код все равно будет работать так, как ожидалось при отладочных сборках. Однако, поскольку журнал удален при сборке выпуска, цикл будет продолжаться бесконечно, поскольку знаменатель не уменьшается.

--------------------------------------------------------------

#### Анатомия трассировки стека

Журнал ошибок, описывающий сбой (также называемый исключением), называется трассировкой стека. Трассировка стека показывает все функции, которые были вызваны до возникновения исключения, начиная с самой последней вызванной. Полный вывод показан ниже.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/1b89567d-2dc2-4483-baf3-4f7c18355941)

Это слишком много текста! К счастью, обычно вам требуется всего несколько фрагментов, чтобы сузить точное количество ошибок. Давайте начнем с самого начала.

 1. java.lang.RuntimeException:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/1a792dc3-0dc3-4ed1-9439-270c6eb99cda)

В первой строке указано, что приложению не удалось запустить действие, что и является причиной сбоя приложения. В следующей строке содержится немного больше информации. В частности, причина, по которой действие не могло начаться, заключалась в ArithmeticException. Более конкретно, тип ArithmeticException был "разделить на ноль".

 2. Caused by:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/7d60d636-b7c3-4ff1-bad4-af241dfb4246)

Если вы прокрутите вниз до строки "Вызвано", там снова будет написано, что произошла ошибка "разделить на ноль". На этот раз он также показывает вам точную функцию, в которой произошла ошибка (division()), и точный номер строки (21). Имя файла и номер строки в окне Logcat снабжены гиперссылками. В выходных данных также отображается имя функции, в которой произошла ошибка, division() и функции, которая ее вызвала, onCreate().

Ничто из этого не должно вызывать удивления, поскольку ошибка была введена намеренно. Однако, если вам нужно определить причину неизвестной ошибки, знание точного типа исключения, имени функции и номера строки предоставляет невероятно полезную информацию.

### Зачем нужна "трассировка стека"?

Термин "трассировка стека" может показаться странным термином для текстового вывода при ошибке. Чтобы лучше понять, как это работает, вам нужно знать немного больше о стеке функций.

Когда одна функция вызывает другую функцию, устройство не будет запускать код из первой функции до завершения работы второй функции. Как только вторая функция завершает выполнение, первая функция возобновляется с того места, где она была прервана. То же самое касается любых функций, вызываемых второй функцией. Вторая функция не возобновит выполнение до завершения третьей функции (и любых других функций, которые она вызывает), а первая функция не возобновится до завершения выполнения второй функции. Это похоже на стопку в физическом мире, такую как стопка тарелок или карточек. Если вы хотите взять тарелку, вам нужно взять самую верхнюю. Невозможно расположить пластину ниже в стеке, предварительно не удалив все пластины над ней.

Стек функций можно проиллюстрировать следующим кодом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/b9947a79-34b6-4a92-a3ed-4b023f7898d1)

Если вы позвоните first(), то номера будут записаны в следующем порядке.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/7ed16015-95d4-4d44-b37b-01c3de6f1cdb)

Почему это? Когда вызывается первая функция, она вызывает ее немедленно, second()поэтому номер 1 не может быть сразу записан. Стек функций выглядит следующим образом.


![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/0854e968-c77e-403c-8515-1b85cda8bf63)

Затем вызывается вторая функция third(), которая добавляет ее в стек функций.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/6b84fafb-e16c-42c5-9fed-def82e02ffcb)

Затем третья функция печатает число 3. Как только она завершает выполнение, она удаляется из стека функций.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/91f86cd5-ee46-41a8-a156-f4a390bfb20c)

Затем second() функция регистрирует номер 2, а затем вызывает fourth(). На данный момент номера 3, а затем 2 были занесены в журнал, и теперь стек функций выглядит следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/39e1b0e3-657c-473c-871f-75a810439626)

fourth() Функция печатает число 4 и удаляется (выталкивается) из стека функций. Затем second() функция завершает выполнение и выталкивается из стека функций. Теперь, когда second() все функции, которые оно вызывало, завершены, устройство выполняет оставшийся код, в first() котором печатается число 1.

Таким образом, числа записываются в следующем порядке: 4, 2, 3, 1.

Потратив время на ознакомление с кодом и сохранив мысленный образ стека функций, вы сможете точно увидеть, какой код выполняется и в каком порядке. Само по себе это может быть мощным методом отладки ошибок, подобных приведенному выше примеру с делением на ноль. Пошаговое выполнение кода также может дать вам хорошее представление о том, куда помещать инструкции журнала, чтобы помочь отлаживать более сложные проблемы.

---------------------------------------------------------------

Примечание: На практике приложение технически может запускать более одной функции Kotlin одновременно. Скорее всего, вы уже сталкивались с приложениями, которые выполняют работу в фоновом режиме, например загружают приложение, пока вы продолжаете просматривать Google Play Store. Это возможно из-за так называемых потоков. С помощью нескольких потоков вы можете выполнять несколько последовательностей кода Kotlin одновременно. Однако каждый поток имеет свой собственный стек функций и работает точно так же, как в примере выше. Использование нескольких потоков (называемое многопоточностью) - это сложная тема, выходящая за рамки данной кодовой лаборатории, но вы узнаете больше о выполнении фоновых операций, когда познакомитесь с сопрограммами Kotlin в разделе 4.

---------------------------------------------------------------
















































