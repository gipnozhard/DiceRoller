# DiceRoller

## 1. Прежде чем вы начнете

Для кодовых лабораторий в этом пути вы будете создавать приложение Dice Roller для Android. Когда пользователь "бросает кости", будет сгенерирован случайный результат. В результате учитывается количество сторон кубика. Например, из 6-стороннего кубика можно выпадать только значения от 1 до 6.

Так будет выглядеть конечное приложение.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/33bf7dcb-c3db-4cf7-843a-d292659c0cfc)

Чтобы помочь вам сосредоточиться на новых концепциях программирования для этого приложения, вы будете использовать браузерный инструмент программирования Kotlin для создания основных функциональных возможностей приложения. Программа выведет ваши результаты на консоль. Позже вы будете реализовывать пользовательский интерфейс в Android Studio.

В этой первой кодовой лаборатории вы создадите программу Kotlin, которая имитирует бросание игральных костей и выдает случайное число, точно так же, как это делают игральные кости.

### Предварительные требования:

 * Как открывать, редактировать и запускать код в https://developer.android.com/training/kotlinplayground

 * Создайте и запустите программу Kotlin, которая использует переменные и функции и выводит результат на консоль.

 * Форматируйте числа в тексте, используя строковый шаблон с ${variable} обозначением.

### Чему вы научитесь:

 - Как программно генерировать случайные числа для имитации бросков костей.

 - Как структурировать свой код, создав Dice класс с переменной и методом.

 - Как создать экземпляр объекта класса, изменить его переменные и вызвать его методы.

### Что вы будете создавать:

 * Программа Kotlin в браузерном инструменте программирования Kotlin, которая может выполнять случайный бросок кости.

### Что вам нужно:

 * Компьютер с подключением к Интернету

## 2. Набирайте случайные числа

В играх часто присутствует элемент случайности. Вы можете получить случайный приз или продвинуться на случайное количество шагов по игровому полю. В повседневной жизни вы можете использовать случайные числа и буквы для создания безопасных паролей!

Вместо того, чтобы бросать реальные кости, вы можете написать программу, которая имитирует бросание костей для вас. Каждый раз, когда вы бросаете кости, результатом может быть любое число в диапазоне возможных значений. К счастью, вам не нужно создавать свой собственный генератор случайных чисел для такой программы. Большинство языков программирования, включая Kotlin, имеют встроенный способ генерации случайных чисел. В этой задаче вы будете использовать код Kotlin для генерации случайного числа.

### Настройте свой начальный код

 1. Откройте веб-сайт в своем браузере https://developer.android.com/training/kotlinplayground.

 2. Удалите весь существующий код в редакторе кода и замените его приведенным ниже кодом. Это main() функция, с которой вы работали в более ранних codelabs.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/5294b418-4b44-4380-9587-d1b81075d8c8)

### Используйте функцию random

Чтобы бросить кости, вам нужен способ представления всех допустимых значений бросков костей. Для обычных 6-гранных костей допустимыми бросками костей являются: 1, 2, 3, 4, 5, и 6.

Ранее вы узнали, что существуют такие типы данных, как Int для целых чисел и String для текста. IntRange - это другой тип данных, и он представляет диапазон целых чисел от начальной точки до конечной. IntRange - это подходящий тип данных для представления возможных значений, которые может дать бросок кости.

 1. Внутри вашей main() функции определите переменную как val вызываемую diceRange. Присвоите ему значение IntRange от 1 до 6, представляющее диапазон целых чисел, которые может бросить шестигранный кубик.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/bf3f5f14-0b13-44b4-81df-6bb69d332773)

Вы можете сказать, что 1..6 это диапазон Kotlin, потому что у него есть начальный номер, две точки, за которыми следует конечный номер (без пробелов между ними). Другими примерами диапазонов целых чисел являются 2..5 для чисел от 2 до 5 и 100..200 для чисел от 100 до 200.

----------------------------------------------------------------

Совет: Обратите внимание, что в этом определении не указано IntRange, точно так же, как вам не нужно было указывать Int or String при создании переменной для целого числа или строки. В большинстве случаев система может определить, какой тип данных вы собираетесь использовать.

Например, система интерпретирует это:

 val diceRange = 1..6

поскольку это:

 val diceRange: IntRange = 1..6

-----------------------------------------------------------------

Аналогично тому, как вызов println() сообщает системе напечатать заданный текст, вы можете использовать вызываемую функцию random() для генерации и возврата случайного числа для вас в заданном диапазоне. Как и раньше, вы можете сохранить результат в переменной.

 2. Внутри main() определите переменную как val вызываемую randomNumber.
 
 3. Сделайте так, чтобы у randomNumber результата вызова было значение random() в diceRange диапазоне, как показано ниже.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/9c1c1211-91ec-4f4e-ac28-b6c8f6cf7328)

Обратите внимание, что вы вызываете random() on diceRange, используя точку между переменной и вызовом функции. Вы можете прочитать это как "генерация случайного числа из diceRange". Затем результат сохраняется в randomNumber переменной.

 4. Чтобы увидеть случайно сгенерированное число, используйте нотацию форматирования строки (также называемую "шаблон строки") ${randomNumber} для его печати, как показано ниже.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/79142c2a-7954-452a-a86b-c42c105a2658)

Ваш готовый код должен выглядеть следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/31221225-2d86-4994-8f6d-44708bacc203)

 5. Запустите свой код несколько раз. Каждый раз вы должны видеть вывод, как показано ниже, с разными случайными числами


![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/d9968ee2-a915-4b5b-8ab7-5244f74de3ec)

---------------------------------------------------------------

 Советы по диапазонам:

 * Диапазоны могут составлять любые целые числа. Допустимыми диапазонами являются следующие: 3..46, 0..270, -6..+6, -10..-4.

 * Вы можете вызывать функции непосредственно в диапазоне, например: (1..6).random().

----------------------------------------------------------------

## 3. Создайте класс Dice

Когда вы бросаете кости, они становятся реальными объектами в ваших руках. Хотя код, который вы только что написали, работает отлично, трудно представить, что речь идет о реальных кубиках. Организация программы так, чтобы она была больше похожа на то, что она представляет, облегчает ее понимание. Итак, было бы здорово иметь программные кости, которые вы можете бросать!

Все кубики работают по существу одинаково. Они обладают одинаковыми свойствами, такими как стороны, и у них одинаковое поведение, например, их можно бросать. В Kotlin вы можете создать программный чертеж кости, в котором указано, что кости имеют стороны и могут выпадать случайным числом. Этот чертеж называется классом.

Затем на основе этого класса вы можете создавать реальные объекты dice, называемые экземплярами объектов. Например, вы можете создать 12-сторонний кубик или 4-сторонний кубик.

--------------------------------------------------------------

Совет: Класс подобен тому, как чертежные планы архитектора - это не сам дом; это инструкции о том, как построить дом. Дом - это реальная вещь, или экземпляр объекта, созданный в соответствии с планом.

---------------------------------------------------------------

---------------------------------------------------------------

Примечание: Организация всего, что связано с dice, в класс называется инкапсуляцией. Инкапсуляция - это большое причудливое слово, но все, что оно означает, это то, что вы можете поместить функциональность, которая логически связана, в одно место.

---------------------------------------------------------------
 
### Определите класс Dice

На следующих шагах вы определите новый класс с именем Dice для представления игральной кости, которую можно бросать.

 1. Чтобы начать заново, очистите код в main() функции, чтобы в конечном итоге получить код, как показано ниже.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/cfc944a7-8d67-4d96-94fd-8387f3782b04)

 2. Под этой main() функцией добавьте пустую строку, а затем добавьте код для создания Dice класса. Как показано ниже, начните с ключевого слова class, за которым следует название класса, а затем открывающая и закрывающая фигурные скобки. Оставьте пробел между фигурными скобками, чтобы поместить ваш код для класса.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/314065d9-aeb2-4395-94d5-c5bdf9a56a1d)

--------------------------------------------------------------

Примечание:

 * Аналогично использованию fun ключевого слова в Kotlin для создания новой функции, используйте class ключевое слово для создания нового класса.

 * Вы можете выбрать любое имя для class, но полезно, если имя указывает, что представляет класс. По соглашению, имя класса записывается в верхнем регистре Camel (также называемом оболочкой Pascal). Например: Car, ParkingMeter и CustomerRecord все допустимые имена классов, и вы можете догадаться, что они представляют.

---------------------------------------------------------------

Внутри определения класса вы можете указать одно или несколько свойств для класса с помощью переменных. Реальные кости могут иметь несколько сторон, цвет или вес. В этой задаче вы сосредоточитесь на свойстве количества сторон кубика.

 3. Внутри Dice класса добавьте var called sides для обозначения количества сторон, которые будут иметь ваши кости. Установите sides значение 6.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/816989ce-3b7f-4631-b352-0bed52a279e9)

Вот и все. Теперь у вас есть очень простой класс, представляющий dice.

### Создайте экземпляр класса Dice

С помощью этого Dice класса у вас есть общее представление о том, что такое dice. Чтобы иметь реальную dice в вашей программе, вам необходимо создать Dice экземпляр объекта. (И если бы вам понадобилось иметь три кубика, вы бы создали три экземпляра объекта.)

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/aa9f2b43-d847-4293-9e1e-d3fd42f3bdec)

 1. Чтобы создать экземпляр объекта Dice, в main() функции создайте val вызываемый myFirstDice и инициализируйте его как экземпляр Dice класса. Обратите внимание на круглые скобки после имени класса, которые означают, что вы создаете новый экземпляр объекта из класса.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/6d222659-d1da-4f99-9e26-e9a3223b9189)

Теперь, когда у вас есть myFirstDice объект, вещь, созданная на основе схемы элементов, вы можете получить доступ к его свойствам. Единственным свойством Dice является its sides. Доступ к свойству осуществляется с помощью "точечной нотации". Итак, чтобы получить доступ к sides свойству myFirstDice, вы вызываете myFirstDice.sides, которое произносится как "myFirstDice точка sides".

 2. Под объявлением myFirstDiceдобавьте println() инструкцию для вывода количества sides из myFirstDice.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/3cde2743-4ed6-4d5c-bb4c-8bd3f993ec63)

---------------------------------------------------------------

Примечание: Ранее при вызове вы использовали точечную нотацию diceRange.random(). В обобщенном виде вы можете думать о точечной нотации как о том, что "над чем-то-точка -выполните некоторое действие". Например, здесь, с myFirstDice.sides надписью "в этом экземпляре получите sides свойство".

---------------------------------------------------------------

Ваш код должен выглядеть примерно так.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/32cabf99-b1cf-46d4-9c30-4c1f3c03b9a8)

 3. Запустите вашу программу, и она должна вывести количество, sides определенное в Dice классе.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/67f0e2ac-cada-4058-a2a2-34e6d25fd310)

Теперь у вас есть Dice класс и настоящая игральная кость, myFirstDice состоящая из 6 sides кубиков.

Давайте бросим кости!

### Заставьте кости броситься

Ранее вы использовали функцию для выполнения операции печати слоев торта. Бросание кубиков также является действием, которое может быть реализовано как функция. И поскольку все кости могут быть брошены, вы можете добавить функцию для этого внутри Dice класса. Функция, которая определена внутри класса, также называется методом.

 1. В Dice классе под sides переменной вставьте пустую строку, а затем создайте новую функцию для броска кубика. Начните с ключевого слова Kotlin fun, за которым следует название метода, за которым следуют круглые скобки (), за которыми следуют открывающие и закрывающие фигурные скобки {}. Вы можете оставить пустую строку между фигурными скобками, чтобы освободить место для большего количества кода, как показано ниже. Ваш класс должен выглядеть следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/a1c5350c-23ee-4310-81f0-4dcb7f2956bb)

--------------------------------------------------------------

Примечание: Вы можете назвать этот метод как угодно, но полезно дать ему имя, указывающее, какое действие он выполняет. Соглашение об именовании функций и методов должно начинаться со строчной буквы, использовать верблюжий регистр и, по возможности, начинаться с глагола действия.

---------------------------------------------------------------

Когда вы бросаете шестигранный кубик, он выдает случайное число от 1 до 6.

 2. Внутри roll() метода создайте val randomNumber. Присвойте ему случайное число в 1..6 диапазоне. Используйте точечную нотацию для вызова random() в диапазоне.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/797f68ad-5f08-4f4d-9253-4fca17790645)

 3. После генерации случайного числа выведите его на консоль. Ваш готовый roll() метод должен выглядеть как приведенный ниже код.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/a80fb682-8d1e-41e3-89d2-8112527944f3)

 4. Чтобы выполнить фактический запуск myFirstDice, в main() вызовите roll() метод on myFirstDice. Вы вызываете метод, используя "точечную нотацию". Итак, чтобы вызвать roll() метод myFirstDice, вы вводите myFirstDice.roll() текст, который произносится как "myFirstDice точка roll()".

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/73237fcd-1f94-4c0b-855b-9a29dad3cfe3)

Ваш завершенный код должен выглядеть следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/38fb9ec5-3b89-4914-b365-644603bdba42)

 5. Запустите свой код! Вы должны увидеть результат случайного броска кости под количеством сторон. Запустите свой код несколько раз и обратите внимание, что количество сторон остается неизменным, а значение броска кости меняется.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/6bb7e00c-12d2-42ee-9043-e24b2b0ea166)

Поздравляем! Вы определили Dice класс с sides переменной и roll() функцией. В main() функции вы создали новый Dice экземпляр объекта, а затем вызвали для него roll() метод для получения случайного числа.

## 4. Возвращает значение вашего броска кубика

В настоящее время вы распечатываете значение randomNumber в своей roll() функции, и это отлично работает! Но иногда более полезно возвращать результат функции тому, что вызвало функцию. Например, вы могли бы присвоить результат roll() метода переменной, а затем переместить игрока на эту величину! Давайте посмотрим, как это делается.

 1. В main() измените строку с надписью myFirstDice.roll(). Создайте val вызываемый diceRoll. Установите его равным значению, возвращаемому roll() методом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/8ccd0717-f817-487b-8118-1661892d7d18)

Это пока ничего не дает, потому что roll() пока ничего не возвращает. Чтобы этот код работал так, как задумано, roll() должен что-то возвращать.

В предыдущих codelabs вы узнали, что вам нужно указать тип данных для входных аргументов функций. Таким же образом вы должны указать тип данных для данных, которые возвращает функция.

 2. Измените roll() функцию, чтобы указать, какой тип данных будет возвращен. В этом случае случайным числом является an Int, поэтому возвращаемый тип является Int. Синтаксис для указания возвращаемого типа следующий: После имени функции, после круглых скобок добавьте двоеточие, пробел, а затем Int ключевое слово для возвращаемого типа функции. Определение функции должно выглядеть как приведенный ниже код.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/188cb5e4-3638-4d2d-a292-0d9c07016203)

 3. Запустите этот код. Вы увидите ошибку в представлении проблем. В нем говорится:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/806ab87b-9f2b-4333-af1c-1f24cf586b2f)

Вы изменили определение функции, чтобы возвращать Int, но система жалуется, что ваш код фактически не возвращает Int. "Тело блока" или "тело функции" относится к коду функции, заключенному в фигурные скобки. Вы можете исправить эту ошибку, вернув значение из функции с помощью return инструкции в конце тела функции.

 4. В roll()удалите println() инструкцию и замените ее return инструкцией for randomNumber. Ваша roll() функция должна выглядеть как приведенный ниже код.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/57175873-2d18-4b6c-bbd0-b55602adc5de)

 5. В main() удалите инструкцию print для сторон кубика.

 6. Добавьте инструкцию для вывода значения sides и diceRoll в информативном предложении. Ваша готовая main() функция должна выглядеть аналогично приведенному ниже коду.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/02208ed4-6eff-4db2-8802-7fd91f4bfb0b)

 7. Запустите свой код, и результат должен быть таким.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/8911c02c-734b-4166-8107-968d919f57d4)

Вот весь ваш код на данный момент.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/4294c30b-88e0-47b2-a721-87c9a3e75d67)

## 5. Измените количество сторон на ваших кубиках

Не у всех кубиков 6 сторон! Кубики бывают всех форм и размеров: 4 стороны, 8 сторон, до 120 сторон!

 1. В вашем Dice классе, в вашем roll() методе измените жестко запрограммированный 1..6 на use sides вместо этого, чтобы диапазон и, следовательно, случайное число, всегда соответствовали количеству сторон.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/1f590358-caf4-4c13-8642-a146e4331b7f)

 2. В main() функции ниже и после печати броска кубика измените значение sides of myFirstDice на 20.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/91519a14-3d6a-479e-b36a-52449f3f1353)

 3. Скопируйте и вставьте существующую инструкцию print ниже после того, как вы изменили количество сторон.

 4. Замените вывод diceRoll на вывод результата вызова roll() метода на myFirstDice.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/f9ef0eea-b230-4269-9abe-afc48aff8176)

Ваша программа должна выглядеть следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/5fad7130-090f-4836-a26c-8a0a131dbbd5)

 5. Запустите свою программу, и вы должны увидеть сообщение для 6-стороннего кубика и второе сообщение для 20-стороннего кубика.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/523c8468-583f-4608-909f-31ace5af36c7)

## 6. Настройте свой dice

Идея класса состоит в том, чтобы представлять вещь, часто что-то физическое в реальном мире. В этом случае Dice класс действительно представляет физическую игральную кость. В реальном мире кости не могут изменять количество сторон. Если вы хотите другое количество сторон, вам нужно получить другие кости. Программно это означает, что вместо изменения свойства sides существующего Dice экземпляра объекта вам следует создать новый экземпляр объекта dice с нужным вам количеством сторон.

В этой задаче вы собираетесь изменить Dice класс, чтобы при создании нового экземпляра можно было указать количество сторон. Измените Dice определение класса, чтобы вы могли указать количество сторон. Это похоже на то, как функция может принимать аргументы для ввода.

 1. Измените Dice определение класса, чтобы оно принимало целое число с именем numSides. Код внутри вашего класса не изменится.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/a9e015be-7731-4734-a4f5-570330b0ee6a)

 2. Внутри Dice класса удалите sides переменную, которую теперь можно использовать numSides.

 3. Кроме того, исправьте диапазон для использования numSides.

Ваш Dice класс должен выглядеть следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/188453ef-ab47-4a65-b488-55f7b92aea51)

Если вы запустите этот код, вы увидите множество ошибок, потому что вам нужно обновить main() для работы с изменениями в Dice классе.

 4. В main()для создания myFirstDice с 6 сторонами теперь необходимо указать количество сторон в качестве аргумента для Dice класса, как показано ниже.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/75ea364d-fa4b-4eb5-bfff-3f5145b97223)

 5. В инструкции print измените sides на numSides.

 6. Ниже удалите код, который изменяется sides на 20, поскольку эта переменная больше не существует.

 7. Также удалите println инструкцию под ним.

Ваша main() функция должна выглядеть как приведенный ниже код, и если вы запустите ее, ошибок быть не должно.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/3925e8b5-76fc-4687-8782-ccc997ff1f6b)

 8. После печати первого броска кубика добавьте код для создания и печати второго Dice объекта с именем mySecondDice с 20 сторонами.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/b334e778-d649-4f85-a42c-f4518787ca92)

 9. Добавьте инструкцию print, которая выполняет свертку и выводит возвращаемое значение.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/630b3ca2-8cdb-474b-a54d-81fa67e46fad)

 10. Ваша готовая main() функция должна выглядеть следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/efbda195-422f-4110-bb0b-aab7c8de1677)

 11. Запустите готовую программу, и ваш результат должен выглядеть следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/4e1e5c4e-6572-45d8-beba-a555a5c362e0)

## 7. Внедряйте передовые методы кодирования

При написании кода лучше использовать краткость. Вы можете избавиться от randomNumber переменной и напрямую возвращать случайное число.

 1. Измените return оператор, чтобы возвращать случайное число напрямую.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/473ec45f-464e-4367-94fb-8509f910a8bb)

Во второй инструкции print вы помещаете вызов для получения случайного числа в строковый шаблон. Вы можете избавиться от diceRoll переменной, выполнив то же самое в первой инструкции print.

 2. Вызовите myFirstDice.roll() в шаблоне string и удалите diceRoll переменную. Первые две строки вашего main() кода теперь выглядят следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/7196d936-cdea-4eb9-a54d-3cd9c0c25708)

 3. Запустите свой код, и на выходе не должно быть никакой разницы.

--------------------------------------------------------------

Примечание: Изменение кода, чтобы сделать его короче, эффективнее или проще для чтения и понимания, называется рефакторингом. Это похоже на написание документа, где вы составляете первый черновик, содержащий всю информацию, а затем редактируете и уточняете свои слова.

---------------------------------------------------------------

Это ваш окончательный код после рефакторинга .

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/ef577527-e1b0-47fb-9f43-e51fefbfc0a9)

## 8. Краткие сведения

 * Вызовите random() функцию для IntRange, чтобы сгенерировать случайное число: (1..6).random()

 * Классы подобны схеме объекта. Они могут иметь свойства и поведение, реализованные в виде переменных и функций.

 * Экземпляр класса представляет объект, часто физический объект, такой как игральная кость. Вы можете вызывать действия над объектом и изменять его атрибуты.

 * Вы можете указать значения классу при создании экземпляра. Например: class Dice(val numSides: Int) а затем создать экземпляр с помощью Dice(6).

 * Функции могут возвращать что-то. Укажите тип данных, который должен быть возвращен в определении функции, и используйте return инструкцию в теле функции, чтобы вернуть что-то. Например: fun example(): Int { return 5 }

# Создайте интерактивное приложение для игры в кости

## 1. Прежде чем начать

В этой кодовой лаборатории вы создадите приложение для игры в кости для Android, в котором пользователи смогут щелкнуть Button в приложении, чтобы бросить кости. Результат броска будет показан на экране в виде TextView.

Вы будете использовать редактор макетов в Android Studio для создания макета своего приложения, а затем напишите код Kotlin для того, что происходит при щелчке на Button.

### Предварительные требования

 * Как создать и запустить приложение "Привет, мир!" в Android Studio.

 * Знакомы с использованием TextViews в приложении.

 * Как изменить атрибуты a TextView в редакторе макетов.

 * Как извлечь текст в строковый ресурс, чтобы упростить перевод вашего приложения и повторное использование строк.

 * Основы программирования Kotlin

### Чему вы научитесь

 - Как добавить Button в приложение для Android.

 - Как добавить поведение при нажатии на Button в приложении.

 - Как открыть Activity код приложения и изменить его.

 - Как отобразить Toast сообщение.

 - Как обновить содержимое TextView во время работы приложения.

### Что вы создадите

 * Приложение Dice Roller для Android, в котором есть Button возможность бросать кости и обновлять текст на экране результатом броска.

### Что вам нужно

 * Компьютер с установленной Android Studio.

Вот как будет выглядеть приложение, когда вы заполните эту кодовую таблицу.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/7345f990-99f4-4ff3-8391-b071d367f5ca)

## 2. Настройте свое приложение

### Создайте пустой проект Activity

 1. Если у вас уже есть существующий проект, открытый в Android Studio, перейдите в Файл> Создать> Новый проект ... 
чтобы открыть экран Создать новый проект.

 2. В Создать новый проект создайте новый проект Kotlin, используя шаблон Пустое действие.

 3. Назовите приложение "Dice Roller" с минимальным уровнем API 19 (KitKat).

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/3b9d7d06-c984-465a-88e3-39c2caf1d330)

Запустите новое приложение, и оно должно выглядеть следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/184846c0-7a74-4502-bff3-d0c9c959475c)

## 3. Создайте макет для приложения

### Откройте редактор макетов

 1. В окне Проекта дважды щелкните activity_main.xml (приложение > разрешение> макет>activity_main.xml), чтобы открыть его. Вы должны увидеть редактор макетов, только с надписью "Hello World" TextView в центре приложения.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/cc58c868-4a99-4818-820e-d9b69ece5265)

Затем вы добавите a Button в свое приложение. A Button - это элемент пользовательского интерфейса в Android, который пользователь может нажать для выполнения действия.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/e2ea0594-2e2e-45f0-9f91-5438af859f42)

В этой задаче вы добавляете Button под надписью "Привет, мир" TextView. TextView и Button будут расположены внутри ConstraintLayout, которое является типом ViewGroup.

Когда они есть Views внутри ViewGroup, они Views считаются дочерними по отношению к родителю ViewGroup. В случае вашего приложения TextView и Button будут считаться дочерними элементами родительского ConstraintLayout.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/85c58914-5407-41c3-8a8c-1c89a159a77d)

Добавьте a Button в качестве дочернего элемента существующего ConstraintLayout в вашем приложении.

---------------------------------------------------------------

Примечание: Как и в генеалогическом древе, в иерархии представлений родительские представления сами по себе могут быть дочерними представлениями, а дочерние представления могут быть родителями для других дочерних представлений.

---------------------------------------------------------------

### Добавьте кнопку в макет

 1. Перетащите символ Button из палитры в представление Дизайн, расположив его под надписью "Hello World" TextView.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/cdb8c177-1357-4e49-8bf3-a5384b5d89b6)

 2. Под палитрой в дереве компонентов убедитесь, что Button и TextView указаны под ConstraintLayout (как дочерние элементы ConstraintLayout).

 3. Обратите внимание на ошибку, что Button не ограничено. Поскольку Button находится внутри ConstraintLayout, вы должны установить вертикальные и горизонтальные ограничения для его позиционирования.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/1c4737ed-8d34-4e75-a38c-6db393548b83)

### Расположите кнопку

На этом шаге вы добавите вертикальное ограничение от верхней части Button до нижней TextView. Это расположит Button под TextView.

 1. В режиме Дизайн, у верхнего края Button, нажмите и удерживайте белый круг с синей рамкой. Перетащите указатель, и за указателем появится стрелка. Отпустите, когда дойдете до нижнего края надписи "Hello World"TextView. При этом устанавливается ограничение на расположение, и Button картинка скользит вверх, оказавшись чуть ниже TextView.

![777](https://github.com/gipnozhard/DiceRoller/assets/71705375/10b0770c-c789-4c59-82f0-3d8671c426fc)

 2. Посмотрите на атрибуты в правой части редактора макетов.

 3. В виджете ограничений обратите внимание на новое ограничение макета, которое установлено в нижней части TextView, Top → BottomOf TextView (0dp). (0dp) означает, что запас равен 0. У вас также ошибка из-за отсутствия горизонтальных ограничений.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/01aa320d-cec4-46ea-b33f-a009c7004be0)

 4. Добавьте горизонтальное ограничение с левой стороны Button к левой стороне родительского элемента ConstraintLayout.

 5. Повторите с правой стороны, соединив правый край Button с правым краем ConstraintLayout. Результат должен выглядеть примерно так:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/0ff61d0a-0a56-4794-8dcd-8b033ff26595)

 6. ButtonПо-прежнему выбранный виджет ограничений должен выглядеть следующим образом. Обратите внимание на два дополнительных ограничения, которые были добавлены: Start → Начало родительского элемента (0dp) и End → Завершение родительского элемента (0dp). Это означает, что игра Button центрирована по горизонтали в своем родительском приложении ConstraintLayout.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/9359a734-bc98-47c8-8375-97f07a3c97b9)

 7. Запустите приложение. Оно должно выглядеть как на скриншоте ниже. Вы можете нажать на Button, но это пока ничего не дает. Давайте продолжим!

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/0dfe4733-1b61-4885-b0b1-0561dd6f5fb0)

### Измените текст кнопки

Вы собираетесь внести еще пару изменений в пользовательский интерфейс в редакторе макетов.

Вместо Button надписи с надписью "Кнопка" измените ее на что-нибудь, указывающее, что кнопка собирается делать: "Бросок".

 1. В редакторе макетов, Button выбрав, перейдите к Атрибутам, измените текст на Roll и нажмите клавишу Enter (Return на Mac).

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/d79ff64c-a8fe-400a-a337-412068b6f7b8)

 2. В дереве компонентов рядом с Button появляется оранжевый предупреждающий треугольник. При наведении указателя на треугольник появляется сообщение. Android Studio обнаружила жестко закодированную строку ("Roll") в коде вашего приложения и предлагает использовать вместо нее строковый ресурс.

Наличие жестко закодированной строки означает, что приложение будет сложнее переводить на другие языки и сложнее повторно использовать строки в разных частях вашего приложения. К счастью, в Android Studio есть автоматическое исправление для вас.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/de888780-617c-4630-8e9b-f6b85b0366e6)

 3. В дереве компонентов щелкните по оранжевому треугольнику.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/0e77bdb8-6eab-4bc8-b9c3-980150777c8f)

Откроется полное предупреждающее сообщение.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/bf47c1c2-922a-49aa-a642-8123dc5e8990)

 4. В нижней части сообщения, в разделе "Предлагаемое исправление", нажмите кнопку "Исправить". (Возможно, вам потребуется прокрутить вниз.)

 5. Откроется диалоговое окно "Извлечь ресурс". Извлечь строку означает взять текст "Roll" и создать строковый ресурс, вызываемый roll в strings.xml (app> res> values> strings.xml ). Значения по умолчанию верны, поэтому нажмите OK.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/7681597e-84b5-485a-bae4-abb1cc5753ee)

 6. Обратите внимание, что в атрибутах в текстовом атрибуте для Button now указано @string/roll, что относится к только что созданному вами ресурсу.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/6c3fe4a5-c514-4b39-9a6f-ed278f4b9121)

В представлении дизайна на нем по-прежнему должно быть написано ButtonRollБросок.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/53ecba8a-76dd-4ee8-9998-404e4dbd393e)

### Оформите текстовое представление

"Привет, мир!" текст довольно маленький, и сообщение не относится к вашему приложению. На этом шаге вы замените маленькое сообщение "Привет, мир!" цифрой, чтобы показать выпавшее значение, и увеличите шрифт, чтобы его было легче разглядеть.

 1. В редакторе дизайна выберите TextView, чтобы его атрибуты отображались в окне Атрибуты.

 2. Измените textSize TextViewна 36sp, чтобы оно было большим и легко читаемым. Возможно, вам потребуется прокрутить страницу, чтобы найти textSize.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/9270e806-4dab-4889-9b8b-01f505bac103)

Очистите атрибут textTextView. Вам не нужно ничего отображать в TextView, пока пользователь не бросит кости.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/a5064ec7-68c6-482d-a53d-3a976cb39b2c)

Однако очень полезно видеть текст в TextView, когда вы редактируете макет и код своего приложения. Для этой цели вы можете добавить в TextView текст, который виден только при предварительном просмотре макета, но не при запуске приложения.

 4. Выберите TextView в дереве компонентов.

 5. В разделе Общие атрибуты найдите атрибут text, а под ним другой текстовый атрибут со значком инструмента. Атрибут text - это то, что будет отображаться пользователю при запуске приложения. Атрибут text со значком инструмента - это атрибут "tools text", который предназначен только для вас как разработчика.

 6. Установите для текста tools значение "1" в TextView (чтобы представить, что у вас бросок кости равен 1). "1" будет отображаться только в редакторе дизайна Android Studio, но оно не будет отображаться при запуске приложения на реальном устройстве или эмуляторе.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/5562e5fe-9724-4bf8-ba6f-492ed584e531)

Обратите внимание, что, поскольку этот текст просматривается только разработчиками приложений, вам не нужно создавать для него строковый ресурс.

 7. Посмотрите на свое приложение в предварительном просмотре. Отображается цифра "1".

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/3b33cbbc-f949-4cd9-b40d-a10b4b49f414)

 8. Запустите свое приложение. Вот как выглядит приложение при запуске на эмуляторе. "1" не отображается. Это правильное поведение.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/febca00c-4212-4f30-b87a-cc61462f533e)

Отлично, вы закончили с изменениями макета!

У вас есть приложение с кнопкой, но если вы нажмете на кнопку, ничего не произойдет. Чтобы изменить это, вам нужно написать некоторый код Kotlin, который бросает кости и обновляет экран при нажатии на кнопку.

Чтобы внести это изменение, вам нужно немного больше понимать структуру приложения для Android.

## 4. Введение в мероприятия

Activity предоставляет окно, в котором ваше приложение отображает свой пользовательский интерфейс. Как правило, Activity an занимает весь экран вашего запущенного приложения. У каждого приложения есть одно или несколько действий. Действие верхнего уровня, или первое действие, часто называется MainActivity и предоставляется шаблоном проекта. Например, когда пользователь прокручивает список приложений на своем устройстве и нажимает на значок приложения "Dice Roller", система Android запускает MainActivity это приложение.

В вашем MainActivity коде вам необходимо предоставить подробную информацию о макете Activity и о том, как пользователь должен взаимодействовать с ним.

 * В приложении для поздравительных открыток есть одно Activity, которое отображает сообщение о дне рождения и изображение.

 * В приложении Dice Roller есть одно, Activity которое отображает только что созданный вами TextView и Button макет.

Для более сложных приложений может быть несколько экрановActivity. У каждого Activity есть определенное назначение.

Например, в приложении "фотогалерея" у вас может быть одно Activity для отображения сетки фотографий, второе Activity для просмотра отдельной фотографии и третье Activity для редактирования отдельной фотографии.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/2735a552-cb34-41c8-a4aa-7ba2c2513956)

### Откройте файл MainActivity.kt

Вы добавите код для ответа на нажатие кнопки в MainActivity. Чтобы сделать это правильно, вам нужно больше узнать о MainActivity коде, который уже есть в вашем приложении.

 1. Перейдите к MainActivity.kt файлу и откройте его (app> java> com.example.diceroller > MainActivity.kt). Ниже приведено то, что вы должны увидеть. Если вы видите import..., нажмите на ..., чтобы развернуть импорт.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/10f7caca-5775-4d96-a1b3-98ef4142df4f)

Вам не обязательно понимать каждое слово приведенного выше кода, но вам необходимо иметь общее представление о том, что оно делает. Чем больше вы работаете с кодом Android, тем более знакомым он становится, и тем больше вы его понимаете.

 2. Посмотрите на код Kotlin для MainActivity класса, обозначенный ключевым словом class, а затем именем.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/e509c037-0267-47f7-94d3-3c444c8e4e77)

 3. Обратите внимание, что в вашем main() приложении нет MainActivity функции.

Ранее вы узнали, что каждая программа Kotlin должна иметь main() функцию. Приложения для Android работают по-разному. Вместо вызова main() функции система Android вызывает ваш onCreate() метод MainActivity при первом открытии вашего приложения.

 4. Найдите onCreate() метод, который выглядит как приведенный ниже код.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/97c6b53d-d9b7-48ec-9a66-bb0374ca8429)

Вы узнаете об override этом позже в codelab (так что пока не беспокойтесь об этом). Остальная часть onCreate() метода настраивает MainActivity, используя код из импорта и устанавливая начальный макет с помощью setContentView().

 5. Обратите внимание на строки, начинающиеся с import.

Android предоставляет фреймворк из многочисленных классов, упрощающий написание приложений для Android, но для этого необходимо точно знать, какой класс вы имеете в виду. Вы можете указать, какой класс фреймворка использовать в вашем коде, используя import инструкцию. Например, Button класс определен в android.widget.Button.

###cВключите автоматический импорт

Не забывать добавлять import инструкции при использовании большего количества классов может оказаться непросто. К счастью, Android Studio помогает вам выбирать правильный импорт при использовании классов, предоставляемых другими. На этом шаге вы настроите Android Studio на автоматическое добавление импорта, когда это возможно, и автоматическое удаление неиспользуемого импорта из вашего кода.

В macOS откройте настройки, перейдя в Файл> Настройки нового проекта> Настройки для новых проектов ... Разверните Другие настройки> Автоматический импорт. В разделах Java и Kotlin убедитесь, что установлены флажки Добавлять однозначный импорт "на лету" и Оптимизировать импорт "на лету" (для текущего проекта). Обратите внимание, что в каждом разделе есть два флажка. Сохраните изменения и закройте настройки, нажав OK.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/35830e63-5019-4c54-9fe7-f685c8da2a71)

В Windows откройте настройки, перейдя в Файл> Настройки> Редактор> Общие> Автоматический импорт. В разделах Java и Kotlin убедитесь, что установлены флажки Добавлять однозначный импорт "на лету" и Оптимизировать импорт "на лету" (для текущего проекта). Обратите внимание, что в каждом разделе есть два флажка. Сохраните изменения и закройте настройки, нажав OK.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/f6d10d35-ba07-44a9-bcd3-5dc1a184a1b9)

Однозначные настройки импорта позволяют Android Studio автоматически добавлять инструкцию import, если она может определить, какую из них использовать. Настройки оптимизации импорта позволяют Android Studio удалить любой импорт, который не используется вашим кодом.

## 5. Сделайте кнопку интерактивной

Теперь, когда вы знаете немного больше о MainActivity, вы измените приложение так, чтобы нажатие на Button вызывало какие-либо изменения на экране.

### При нажатии кнопки отображается сообщение

На этом шаге вы укажете, что при нажатии на кнопку в нижней части экрана отображается краткое сообщение.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/dacc9bd1-efad-414f-9c3a-0886fcc09d19)

 1. Добавьте следующий код в onCreate() метод после setContentView() вызова. findViewById() Метод находит Button в макете. R.id.button - идентификатор ресурса для Button, который является уникальным идентификатором для него.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/d9708705-983d-4dbe-ae32-253bf04abd1a)

---------------------------------------------------------------

Примечание: Android автоматически присваивает идентификационные номера ресурсам вашего приложения. Например, кнопка Roll имеет идентификатор ресурса, и строка для текста кнопки также имеет идентификатор ресурса. Идентификаторы ресурсов имеют вид R.<type>.<name>; например, R.string.roll. Для View идентификаторов <type> это id, например, R.id.button.

---------------------------------------------------------------

Код сохраняет ссылку на Button объект в вызываемой переменной rollButton, а не сам Button объект.

---------------------------------------------------------------

Важно: Когда Kotlin присваивает объект переменной, он не копирует объект целиком каждый раз, а сохраняет ссылку на объект. Вы можете придумать ссылку, похожую на национальный идентификационный номер; номер относится к человеку, но это не сам человек. Когда вы копируете номер, вы не копируете человека.

---------------------------------------------------------------

onCreate() Теперь метод должен выглядеть следующим образом:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/29c84f97-5c81-4f4a-b965-64358b3c1ee9)

 2. Убедитесь, что Android Studio автоматически добавила import инструкцию для Button. Обратите внимание, что теперь есть 3 инструкции импорта.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/aa9b4754-a16c-4ac8-be57-ecfdfabb2ebd)

---------------------------------------------------------------

Примечание: Если включение автоматического импорта не сработало, оно Button будет выделено красным. Вы можете вручную добавить правильный импорт, поместив текстовый курсор в словоButton, затем нажав Alt+Enter (Option+Enter на Mac).

---------------------------------------------------------------

Далее вам нужно связать код с Button, чтобы код мог выполняться при нажатии на Button. Прослушиватель кликов - это некоторый код для того, что делать, когда происходит нажатие. Вы можете думать об этом как о коде, который просто сидит, "слушая", как пользователь нажимает, в данном случае, на Button.

 3. Используйте rollButton объект и установите для него прослушиватель кликов, вызвав setOnClickListener() метод. Вместо круглых скобок, следующих за именем метода, вы фактически будете использовать фигурные скобки, следующие за именем метода. Это специальный синтаксис для объявления лямбда-выражения, о котором вы узнаете больше в будущей codelab.
 4. 
На данный момент вам нужно знать, что внутри фигурных скобок вы помещаете инструкции о том, что должно произойти при нажатии на кнопку. На следующем шаге ваше приложение отобразит всплывающее окно, представляющее собой краткое сообщение.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/236e39c9-7893-40cc-9d4e-806524f68982)

По мере ввода Android Studio может отображать несколько предложений. В этом случае выберите опцию setOnClickListener {...}.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/5cdd8b83-bb5c-402d-b9ec-5ed06b5db8d3)

В фигурных скобках вы помещаете инструкции о том, что должно произойти при нажатии на кнопку. На данный момент ваше приложение будет отображать Toast, которое представляет собой краткое сообщение, отображаемое пользователю.

 4. Создайте приложение Toast с текстом"Dice Rolled!", позвонив Toast.makeText().

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/fdf66663-3d22-4117-b3e2-df2ad1263afd)

 5. Затем попросите Toast отобразить себя, вызвав show() метод.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/3a643b96-c985-4407-bb44-22a47c5bed49)

Вот как выглядит ваш обновленный MainActivity класс; инструкции package and import по-прежнему находятся в верхней части файла:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/670e5ce5-331c-4593-aa8c-c8ecfdca8352)

Вы могли бы объединить две строки в прослушивателе кликов в одну строку без переменной. Это распространенный шаблон, который вы можете найти в другом коде.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/c74a59a8-0cdd-43f4-8153-fae134baf7f0)

 6. Запустите приложение и нажмите кнопку Roll. В нижней части экрана должно появиться всплывающее сообщение, которое через короткое время исчезнет.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/5815c6d2-8821-42a7-a2cd-dd662079ef92)

Ура! При нажатии кнопки появилось всплывающее сообщение! Вы впервые пишете код Kotlin для Android!

### Обновляйте текстовое представление при нажатии кнопки

Вместо отображения временного Toast сообщения вы напишете код для обновления TextView на экране при нажатии кнопки броска.

 1. Вернитесь к activity_main.xml (приложение > разрешение> макет>activity_main.xml)

 2. Нажмите на TextView.

 3. Обратите внимание, что идентификатором является TextView.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/07a16a00-6b44-4c30-981d-cb4b9e71d91a)

 4. Откройте MainActivity.kt (app> java> com.example.diceroller> MainActivity.kt)

 5. Удалите строки кода, которые создают и показываютToast.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/600f68a0-af0b-43a1-a49b-7d1c0170c5b9)

 6. Вместо них создайте новую переменную с именем resultTextView для хранения TextView.

 7. Используйте findViewById() для поиска textView в макете по его идентификатору и сохраните ссылку на него.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/13bf0a98-9aed-46bb-80a1-2801b4bf0ff2)

 8. Установите значение текста на resultTextView равным "6" в кавычках.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/8014f69e-3895-4058-8513-a74b710ef523)

Это похоже на то, что вы сделали, установив текст в атрибутах, но теперь это в вашем коде, поэтому текст должен быть заключен в двойные кавычки. Установка этого параметра явно означает, что на данный момент TextView всегда отображается 6. Вы добавите код для броска кости и отображения других значений в следующей задаче.

Вот как должен выглядеть MainActivity класс:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/fb6f673e-c7d5-4507-8b3d-c8a4a29934c9)

 9. Запустите приложение. Нажмите кнопку. Оно должно обновить TextView значение до "6".

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/be2eb8bd-fbd7-42ac-b033-b071b30f1128)

## 6. Добавьте логику броска костей

Единственное, чего не хватает, - это бросать кости. Вы можете повторно использовать Dice класс из предыдущей codelab, который обрабатывает логику для бросания кости.

### Добавьте класс Dice

 1. После последней фигурной скобки в MainActivity классе создайте Dice класс с roll() методом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/af7b844b-a42b-4e36-891a-48e8c5cf7fd6)

 2. Обратите внимание, что Android Studio может подчеркивать numSides волнистой серой линией. (Для появления этого может потребоваться некоторое время.)

 3. Наведите указатель мыши на numSides, и появится всплывающее окно с сообщением, что свойство ‘numSides' может быть закрытым.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/b1145912-3b99-46d7-aa86-14b57acacf32)

Пометка numSides как private сделает его доступным только в Dice классе. Поскольку единственный код, который будет использоваться, numSides находится внутри Dice класса, можно использовать этот аргумент private для Dice класса. Вы узнаете больше о private сравнении public переменных в следующем разделе.

 4. Продолжайте и внесите предложенное исправление в Android Studio, нажав Сделать ‘numSides' ‘приватным'.

### Создайте метод rollDice()

Теперь, когда вы добавили Dice класс в свое приложение, вы обновите MainActivity его, чтобы использовать. Чтобы лучше организовать свой код, поместите всю логику о броске кости в одну функцию.

 1. Замените код в прослушивателе кликов, который устанавливает текст равным "6", на вызов rollDice().

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/ee53c3ff-1c44-4f23-82a1-578a389a1433)

 2. Поскольку rollDice() оно еще не определено, Android Studio выдает ошибку и отображается rollDice() красным цветом.

 3. При наведении указателя на rollDice() Android Studio отображает проблему и некоторые возможные решения.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/a1d241c4-d5cb-49aa-b500-1c31f716b134)

 4. Нажмите на Дополнительные действия ... откроется меню. Android Studio предлагает выполнить больше работы за вас!

---------------------------------------------------------------

Совет: Если вам трудно навести указатель, а затем нажать на Дополнительные действия ... вы можете нажать на rollDice() и далее Alt+Enter (Option+Enter на Mac), чтобы вызвать меню.

---------------------------------------------------------------

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/198cf7eb-fac8-4073-b615-09e238eccb3c)

 5. Выберите Создать функцию ‘rollDice'. Android Studio создает пустое определение для функции внутри MainActivity.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/8afc9272-fe52-4205-b915-5afe998c056d)

### Создайте новый экземпляр объекта Dice

На этом шаге вы заставите rollDice() метод создать и бросить кости, а затем отобразите результат в TextView.

 1. Внутри rollDice() удалите TODO() вызов.

 2. Добавьте код для создания кости с 6 сторонами.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/21ef912a-d279-4bcb-b642-9490155ec799)

 3. Бросьте кости, вызвав roll() метод, и сохраните результат в переменной с именем diceRoll.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/dde4f259-bc38-4606-9c04-a51a1a90e543)

 4. Найдите приложение, TextView позвонив findViewById().

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/aac976ba-e012-4de8-83a1-5af7ab9ce286)

Переменная diceRoll представляет собой число, но TextView использует текст. Вы можете использовать toString() метод на diceRoll, чтобы преобразовать его в строку.

 5. Преобразуйте diceRoll в строку и используйте ее для обновления текста resultTextView.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/e02b1325-1f13-4bf8-8dc3-4c66245bea9f)

Вот как выглядит rollDice() метод:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/5ff9c36c-ad2d-42cc-aa95-ed9e1476fb61)

 6. Запустите свое приложение. Результат игры в кости должен измениться на другие значения, кроме 6! Поскольку это случайное число от 1 до 6, иногда может отображаться и значение 6.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/3076e440-9ef7-4c6d-a312-c6de0bc1f155)

Ура, ты молодец!

## 7. Внедряйте передовые методы кодирования

Обычно ваш код выглядит немного неаккуратно после того, как вы кое-где подправляете отдельные части, чтобы заставить ваше приложение работать. Но прежде чем вы уйдете от своего кода, вам следует выполнить несколько простых действий по очистке. Тогда приложение будет в хорошей форме, и его будет проще поддерживать в дальнейшем.

Именно эти привычки практикуют профессиональные разработчики Android при написании своего кода.

### Руководство по стилю Android

При командной работе членам команды идеально писать код аналогичным образом, чтобы обеспечить некоторую согласованность всего кода. Вот почему в Android есть руководство по стилю написания кода Android — соглашения об именовании, форматирование и другие рекомендации, которым следует следовать. При написании кода для Android соблюдайте эти рекомендации: Руководство по стилю Kotlin для разработчиков Android.

Ниже приведены несколько способов, которыми вы можете придерживаться руководства по стилю.

### Очистите свой код

#### Уплотните свой код

Вы можете сделать свой код более кратким, сократив его до меньшего количества строк. Например, вот код, который устанавливает прослушиватель кликов на Button.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/38b7ac4b-3be3-4f75-a6f8-26e6a31aeb1e)

Поскольку инструкции для прослушивателя кликов занимают всего 1 строку, вы можете свести rollDice() вызов метода и фигурные скобки в одну строку. Вот как это выглядит. Одна строка вместо трех строк!

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/85cee00e-ddeb-4850-85ca-a8f13b661ff0)

#### Переформатируйте свой код

Теперь вы переформатируете свой код, чтобы убедиться, что он соответствует рекомендуемым соглашениям о форматировании кода для Android.

 1. В MainActivity.kt классе выделите весь текст в файле с помощью сочетания клавиш Control+A в Windows (или Command+A на Mac). Или вы могли бы перейти в меню в Android Studio Правка> Выбрать все.

 2. Выделив весь текст в файле, перейдите в меню Android Studio Код> Переформатировать код или используйте сочетание клавиш Ctrl+Alt+L (или Command+Option+L на Mac).

Которое обновит форматирование вашего кода, включая пробелы, отступы и многое другое. Возможно, вы не увидите никаких изменений, и это хорошо. Тогда ваш код уже был правильно отформатирован!

### Прокомментируйте свой код

Добавьте несколько комментариев к своему коду, чтобы описать, что происходит в написанном вами коде. По мере усложнения кода также важно учитывать, почему вы написали код, который работает так, как вы это сделали. Если вы вернетесь к коду позже, чтобы внести изменения, что делает код, возможно, все еще будет понятно, но вы можете не вспомнить, почему написали его таким образом.

Обычно для каждого класса (MainActivity и Dice - единственные классы, которые есть в вашем приложении) и каждого метода, который вы пишете, добавляется комментарий. Используйте символы /** и */ в начале и конце вашего комментария, чтобы сообщить системе, что это не код. Эти строки будут проигнорированы, когда система выполнит ваш код.

Пример комментария к классу:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/af987ed3-0b4a-4642-adba-e6365ff5eb7e)

Пример комментария к методу:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/6fcb604d-1b77-43bc-b77e-2fc6c9494687)


В рамках метода вы можете добавлять комментарии, если это поможет читателю вашего кода. Напомним, что вы можете использовать // символ в начале своего комментария. Все, что находится после // символа в строке, считается комментарием.

Пример двух комментариев внутри метода:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/90411aa3-62ef-467a-b509-dad9a38e7852)

 1. Продолжайте и уделите некоторое время добавлению комментариев к вашему коду.

 2. Учитывая все эти изменения в комментариях и форматировании, рекомендуется повторно запустить ваше приложение, чтобы убедиться, что оно по-прежнему работает должным образом.

Смотрите код решения для одного из способов, которым вы могли бы прокомментировать свой код.

## 8. Код решения

Код решения для этой кодовой лаборатории находится в проекте и модуле, показанных ниже.

--------------------------------------------------------------

URL-адрес кода решения: https://github.com/google-developer-training/android-basics-kotlin-create-dice-roller-with-button-app-solution

--------------------------------------------------------------

Чтобы получить код для этой кодовой лаборатории и открыть ее в Android Studio, выполните следующие действия.

### Получите код

 1. Нажмите на предоставленный URL. Откроется страница проекта на GitHub в браузере.

 2. Проверьте и убедитесь, что название филиала совпадает с названием филиала, указанным в codelab. Например, на следующем скриншоте название филиала - main.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/77f97691-b003-42fc-ad8b-e7bc1c8001fa)

 3. На странице проекта в GitHub нажмите кнопку Code, которая вызовет всплывающее окно.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/48c1103c-849d-42c5-8ebf-c6f5d11cc58f)

 4. Во всплывающем окне нажмите кнопку Загрузить ZIP, чтобы сохранить проект на свой компьютер. Дождитесь завершения загрузки.

 5. Найдите файл на своем компьютере (скорее всего, в папке Downloads).

 6. Дважды щелкните ZIP-файл, чтобы распаковать его. При этом будет создана новая папка, содержащая файлы проекта.

### Откройте проект в Android Studio

 1. Запустите Android Studio.

 2. В окне Добро пожаловать в Android Studio нажмите Открыть.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/0e534eb4-3e66-4be1-8ee7-bf0b6c920da9)

Примечание: Если Android Studio уже открыта, вместо этого выберите пункт меню Файл> Открыть.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/16418208-13fa-4017-8940-a0dbccef9e62)

 3. В браузере файлов перейдите туда, где находится папка с распакованным проектом (скорее всего, в папке "Ваши загрузки").

 4. Дважды щелкните по папке этого проекта.

 5. Подождите, пока Android Studio откроет проект.

 6. Нажмите кнопку "Выполнить8de56cba7583251f.png", чтобы создать и запустить приложение. Убедитесь, что оно построено должным образом.

## 9. Краткие сведения

 * Добавьте Button в приложение для Android с помощью редактора макетов.

 * Измените MainActivity.kt класс, чтобы добавить интерактивное поведение в приложение.

 * В качестве временного решения отобразите Toast сообщение, чтобы убедиться, что вы на правильном пути.

 * Установите прослушиватель по щелчку для Button использования setOnClickListener() для добавления поведения при щелчке Button.

 * Когда приложение запущено, вы можете обновить экран, вызвав методы TextView, Button или другие элементы пользовательского интерфейса в макете.

 * Прокомментируйте свой код, чтобы помочь другим людям, которые читают ваш код, понять, в чем заключался ваш подход.

 * Переформатируйте свой код и очистите его.

# Добавить условное поведение в Kotlin

## 1. Прежде чем начать

В этой кодовой лаборатории Kotlin вы создадите еще одну игру в кости, Lucky Dice Roll, пытаясь выпадение счастливого числа. Ваша программа установит счастливое число и бросит кости. Затем вы сверяете выпавшее число со счастливым и выводите соответствующее сообщение на выходе. Чтобы выполнить это, вы узнаете, как сравнивать значения и принимать различные решения в вашей программе Kotlin.

Чтобы помочь вам сосредоточиться на концепциях программирования, не беспокоясь о пользовательском интерфейсе приложения, вы будете использовать браузерный инструмент программирования Kotlin и выводить свои результаты на консоль.

### Предварительные требования

 * Как открывать, редактировать и запускать код в https://developer.android.com/training/kotlinplayground

 * Возможность создавать и запускать программу Kotlin, которая использует переменные, функции с аргументами, классы с методами и выводит результат на консоль.

### Чему вы научитесь

 Как использовать инструкции if и else .

 Как сравнивать значения с помощью таких операторов, как больше (>), меньше (<) и равно (==).

 Как использовать when инструкции для выбора параметра на основе заданного значения.

 Что такое Boolean тип данных и как использовать его true и false значения для принятия решений.

### Что вы будете создавать

 * Игра в кости на основе Kotlin, Lucky Dice Roll, которая позволяет указать счастливое число. Игрок выиграет, если выпадет счастливое число.

### Что вам нужно

 * Компьютер с подключением к Интернету.


## 2. Принятие решений в вашем коде

Ваша программа Lucky Dice Roller должна определить, выпал ли пользователь счастливый номер и получает ли он поздравление или вместо этого получает сообщение с просьбой повторить попытку.

Как разработчику приложения, вам необходимо принимать решения о том, как должно вести себя приложение, и создавать различные результаты для ваших пользователей.

Если вы создаете приложение для покупок, вы можете показывать разные экраны в зависимости от выбранных пользователем вариантов доставки. В викторине вы бы показывали разные экраны в зависимости от того, правильный ли ответ дал игрок. В зависимости от приложения может быть много возможных результатов, которые вы захотите учесть в своем коде.

В вашей программе Lucky Dice Roller приложение должно обрабатывать различные случаи, такие как:

 * Если выпадет счастливое число, то отобразите поздравительное сообщение!

 * Иначе, если выпавшее число не является счастливым, отобразите сообщение с просьбой повторить попытку.
Чтобы добавить эту логику в свой код, используйте специальные ключевые слова Kotlin, такие как if и else и when.

Давайте рассмотрим несколько примеров.

### Используйте if инструкцию для настройки условия, которое выполняется

 1. Ознакомьтесь с приведенным ниже кодом. Можете ли вы догадаться, каким будет результат?

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/4af3086a-99a4-4a21-abfc-bb8079f761fc)

 2. Скопируйте и вставьте код в редактор программ Kotlin и запустите программу, чтобы просмотреть результат.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/dd485f91-4723-43f3-bb9d-2f24b79d975c)

Процесс принятия решений для этой программы является:

 1. Создайте переменную num и установите для нее значение 5 

 2. Если верно, что num больше 4, выведите "The variable is greater than 4".

 3. Во всех других ситуациях ничего не делайте.

В приведенном выше примере, num установлено значение 5. ifИнструкция сравнивает, если переменная больше 4. Поскольку это верно, система затем выполняет инструкции, заключенные в фигурные скобки, и печатает сообщение.

--------------------------------------------------------------

Резюме: > symbol - это оператор для сравнения двух значений, независимо от того, больше ли первое значение второго значения, и возврата результата true или false. Другими распространенными операторами являются: < для меньше, == для равно, >= для большего или равного и <= для меньшего или равного.

--------------------------------------------------------------

Обратите внимание на общие формата if заявление:

 * Начните с ключевого слова if .
 
 * Далее следуют две круглые скобки (). Внутри круглых скобок указано условие. Условием является все, что может быть true или false. Например, является ли число больше другого числа.

 * Заключите в две фигурные скобки {}. Внутри фигурных скобок вы помещаете код для выполнения, если условие равно true.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/76ae6e5f-8314-4493-b102-0016f11c9a2a)

--------------------------------------------------------------

### Логический тип данных для значений true и false:

 * Программа, проверяющая, выполнено ли условие, называется "оценкой условия". Результатом оценки условия является true если оно выполнено, или false если оно не выполнено. Разработчики также говорят: "условие оценивается как true" или "условие оценивается как false".

 * Условия могут оцениваться только для true или false.
 
 * Точно так же, как существует тип данных Int для целых чисел и IntRange для диапазонов, существует тип данных для true и false, называемый Boolean. Вы столкнетесь с Boolean переменными типа позже в этом курсе.

--------------------------------------------------------------

### Используйте if инструкцию для настройки условия, которое не выполняется

 1. Измените значение num на 3, как показано ниже. Что, по-вашему, произойдет, если вы запустите этот код?

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/d69778ed-4294-4b2e-8dd9-ff3576dfd158)

 2. Скопируйте и вставьте код в редактор программ Kotlin и запустите программу, чтобы увидеть пустой результат.

При num значении 3 ничего не печатается, потому что значение num меньше 4. Таким образом, условие, при котором num должно быть больше 4, равно false, и код, заключенный в фигурные скобки, не будет выполняться, и ничего не будет напечатано.

### Используйте else для создания альтернативы для неудачных условий

Вместо того, чтобы ничего не делать, вы можете предложить своим пользователям альтернативу, когда условие не выполняется. Так же, как и в обычном языке, вы можете сделать это с помощью инструкции else .

 1. Добавьте инструкцию else для печати сообщения, когда num не превышает 4, как показано ниже. Что, по-вашему, произойдет, если вы запустите этот код?

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/b852af85-e622-4cb3-83a0-28164f6dd755)

 2. Скопируйте и вставьте код в редактор программ Kotlin и запустите программу, чтобы просмотреть результат.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/1ff1f2c1-a6ab-4d8c-9203-cb5a12b90d4f)

 3. Обратите внимание, что когда num имеет значение 3, программа печатает сообщение "The variable is less than 4", связанное с оператором else , поскольку num не превышает 4.

 4. Измените num на 5 и запустите программу снова. Теперь верно, что num больше 4, и программа печатает "The variable is greater than 4".

 5. Измените num на 4 и запустите свою программу. Теперь 4 не больше 4, и программа печатает "The variable is less than 4".

Хотя "The variable is less than 4" является правильным выводом для условий, которые вы задаете в коде, этот напечатанный оператор неточен, поскольку 4 не меньше 4. Что вы можете сделать, так это добавить другое условие, которое проверяет наличие третьей возможности, то есть, точно ли num равно 4, и выводит правильное утверждение, когда это условие выполняется.

### Используйте комбинацию else if для добавления альтернативных условий

У вас может быть более одного условия. В вашем примере вот как вы можете охватить все возможности для num:

 * Если num больше 4, выведите "The variable is greater than 4".

 * Иначе, если num равно 4, выведите "The variable is equal to 4".

 * Ещё, распечатать "The variable is less than 4".

В инструкции if-else они называются разными случаями. В списке перечислены 3 случая.

Обновленный код выглядит следующим образом:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/ac28ecb9-18ad-4a35-8363-7a4ecde5d12c)

Обратите внимание на следующие изменения:

 * Значение num теперь равно 4, чтобы вы могли протестировать новое условие.

 * Между исходными операторами if и else находится новый оператор else if для случая, когда num равно ровно 4.

 1. Скопируйте и вставьте приведенный выше код в редактор программ Kotlin и запустите программу, чтобы просмотреть результат.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/a7273b7a-58b0-4c52-a09f-f6c093da754f)

 2. Поэкспериментируйте с изменением значения num и посмотрите, как это влияет на результат. Измените num на 2 и 6, чтобы вы могли видеть, как выполняются каждое из условий. true.

###Поток управления

Когда вы смотрите на приведенные выше инструкции if-else, код будет выполняться или протекать так, как управляется условиями. Таким образом, способ, которым вы управляете выполнением с помощью этих условий, называется "потоком управления" программой.

 * Допустим, ваш бросок кости num равен 3. Программа проверяет первое условие (num> 4). Это значение равно false, поэтому программа проверяет следующее условие (num == 4), которое также равно false. Затем программа выполняет код оператора else, который является окончательным вариантом.

 * Если число бросков костей равно 6, то первое условие (num> 4) выполняется. Программа печатает сообщение "The variable is greater than 4". Поскольку это условие истинно, оно не должно проверять остальные и выполняется с помощью оператора if-else .

 * Используйте комбинацию else + if для добавления альтернативных условий.

## 3. Создайте игру "Счастливый бросок костей"

В этом разделе, используя то, что вы узнали из предыдущего задания, вы обновите программу Dice Roller, чтобы проверить, выпало ли вам заранее установленное счастливое число. Если выпало, вы выигрываете!

### Настройте свой стартовый код

Вы запускаете Lucky Dice Roller с кодом, похожим на код решения предыдущей программы Kotlin Dice Roller. Вы можете отредактировать main() выполните соответствующую функцию в вашем предыдущем коде, или вы можете скопировать и вставить приведенный ниже код, чтобы начать работу.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/81d042bf-c085-47c3-8466-a4b51c537fde)

--------------------------------------------------------------

Примечание: Каждый раз, когда вы запускаете вышеупомянутую программу на игровой площадке, вызывается функция main() . При этом создается новый экземпляр Dice и вызывается roll() метод для него. Таким образом, каждый раз, когда вы запускаете программу, значение броска кубика может отличаться.

-------------------------------------------------------------

### Проверьте, выпало ли счастливое число

Сначала создайте счастливое число, а затем сравните бросок кости с этим числом.

 1. В main() удалите инструкцию println() .

 2. В main() добавьте val вызываемое luckyNumber и установите для него значение 4. Ваш код должен выглядеть следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/059caf7d-3e31-4350-974c-6afe822eaf37)

 3. Ниже добавьте оператор if с условием внутри круглых скобок () , которое проверяет, равно ли rollResult (==) luckyNumber. Оставьте немного места между фигурными скобками {} , чтобы вы могли добавить больше кода.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/5ab5d780-3a53-4e39-88a9-40e5dcea1280)

 4. Внутри фигурных скобок {} добавьте println инструкцию для печати "You win!"

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/5f49d839-c68a-4d5d-a255-bf9d93e1c52f)

 5. Запустите свою программу. Возможно, вам придется запустить ее несколько раз, прежде чем вам улыбнется удача и вы увидите сообщение о выигрыше в выходных данных!

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/b7d6bbb8-543f-4a32-ada3-3620362f8c46)

### Отвечать, если счастливое число не выпало

Отсутствие обратной связи от программы, если пользователь не выиграл, может заставить их задуматься, не сломана ли программа. Хорошей практикой является всегда предоставлять ответ, когда пользователь что-то делает. В программе Lucky Dice Roller вы можете сообщить игрокам, что они не выиграли, с помощью инструкции else .

 1. Добавить инструкцию else для печати "You didn't win, try again!".

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/f7a25d71-a79e-4ef0-bfd4-f8dc764db013)

 2. Запустите программу, и независимо от результата ваши пользователи всегда будут уведомлены.

На этом этапе пользователи знают, выиграли они или нет, но не почему. Всегда предоставляйте пользователям информацию, чтобы они понимали результат своих действий! Представьте, что ваша программа - это заявка на получение кредита. "Вы не получили одобрение, потому что у вас низкий кредитный рейтинг" - это намного более информативно, чем "Извините, вам не выдали кредит, попробуйте еще раз!" Для Lucky Dice Roller вы можете предоставлять пользователям разные информационные сообщения для каждого броска, если они проиграли. Для этого используйте несколько операторов else if .

 3. Добавить else if инструкции для печати разных сообщений для каждого рулона. При необходимости обратитесь к формату, который вы изучили в предыдущей задаче.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/7162acf7-345d-4777-86ab-45746df8ec45)

В приведенном выше коде вы

 * Проверить rollResult это luckyNumber.

 * Если значение rollResult равно значению luckyNumber, выведите сообщение о выигрыше.

 * В противном случае проверьте, равно ли значение rollResult 1, и если да, выведите сообщение о повторной попытке.

 * В противном случае проверьте, равно ли значение rollResult 2, и если да, выведите другое сообщение о повторной попытке.

 * В противном случае продолжайте проверять с помощью числа 5.

 * Если число не было ни одним из 1-5, остается единственный вариант - 6, поэтому нет необходимости в другом тестировании с помощью else if, и вы можете просто перехватить этот последний вариант с помощью оператора final else .

--------------------------------------------------------------

Совет: У вас может быть только один оператор if с одним оператором else в блоке кода if-else, но между ними у вас может быть столько операторов else if , сколько вам нужно.

--------------------------------------------------------------

Поскольку наличие нескольких else if вариантов очень распространено, у Kotlin есть более простой способ их написания.

### 4. Используйте оператор when

Тестирование для множества различных результатов или случаев очень распространено в программировании. Иногда список возможных результатов может быть очень длинным. Например, если вы бросаете 12-гранный кубик, у вас будет 11 else if операторы между успешным выполнением и окончательным else. Чтобы упростить написание и чтение такого рода инструкций, что помогает избежать ошибок, Kotlin предоставляет инструкцию when .

Вы собираетесь изменить свою программу, чтобы использовать инструкцию when . whenИнструкция начинается с ключевого слова when, за которым следуют круглые скобки (). Внутри круглых скобок находится значение для проверки. За ним следуют фигурные скобки {} чтобы код выполнялся при других условиях.

 1. В вашей программе в разделе main() выберите код от первого оператора if до фигурной скобки } , которая закрывает последний оператор else , и удалите его.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/92a74304-5ab3-44f1-865a-35a4294182ae)

 2. В main(), под объявлением luckyNumber, создайте оператор when . Поскольку вашему when необходимо протестировать свернутый результат, поместите rollResult между круглыми скобками (). Добавьте фигурные скобки {} с некоторым дополнительным интервалом, как показано ниже.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/3da8ce20-7944-402d-9bd6-f8e7b35325e5)

Как и раньше, сначала проверьте, rollResult совпадает ли оно с luckyNumber.

 1. Внутри фигурных скобок {} инструкции when добавьте инструкцию, которая проверяет rollResult на luckyNumber соответствие, и, если они совпадают, выведите сообщение о выигрыше. Инструкция выглядит следующим образом:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/8ebdfa42-50b4-47df-be13-1b1830ed11b1)

Это означает:

 * Сначала вы вводите значение, с которым сравниваете rollResult. Это luckyNumber.

 * Проследите за этим с помощью стрелки (->).

 * Затем добавьте действие, которое будет выполняться при наличии совпадения.

Прочтите это как "Если rollResult равно luckyNumber, то выведите сообщение "You win!" ".

И ваш main() код будет выглядеть примерно так.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/009bba9e-a342-4ec3-ba09-f01bbe14875b)

 2. Используйте тот же шаблон для добавления строк и сообщений для возможных бросков 1-6, за исключением 4, как показано ниже. Ваша готовая main() функция должна выглядеть следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/1d6f6831-7919-4b87-8ef3-6642c0cf35ef)

 3. Запустите свою программу. Разницы в выходных данных нет, но ваш код намного компактнее и его легче читать.

Поздравляем! Вы изучили два способа печати сообщений в зависимости от условия. Это мощный инструмент для написания интересных программ!

## 5. Краткие сведения
 * Используйте инструкцию if , чтобы задать условие для выполнения некоторых инструкций. Например, если пользователь выпал счастливый номер, выведите сообщение о выигрыше.

 * BooleanТип данных имеет значения true и false и может использоваться для принятия решений.

 * Сравните значения, используя такие операторы, как больше (>), меньше (<) и равно (==).

 * Используйте цепочку операторов else if для задания нескольких условий. Например, выведите разное сообщение для каждого возможного броска кости.
 
 * Используйте оператор else в конце цепочки условий, чтобы отслеживать любые случаи, которые могут быть не охвачены явно. Если вы охватываете случаи для 6-стороннего кубика, else оператор будет перехватывать числа 7 и 8, выпавшие с помощью 8-стороннего кубика.
 
 * Используйте инструкцию when как компактную форму выполнения кода, основанную на сравнении значения.

### Общая форма if-else:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/7a0fcf5d-9143-46ae-8b06-21bb89a6a3e6)

### Оператор When:

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/cebe3f2b-e66e-42ff-a4dd-dfe7e7898755)

## Добавление изображений в приложение Dice Roller

### 1. Прежде чем начать

В этой кодовой лаборатории вы добавите изображения dice в существующее приложение Dice Roller для Android. Сначала обязательно заполните предыдущую кодовую лабораторию по созданию основы приложения Dice Roller.

Вместо отображения значения броска кости в a TextView ваше приложение отобразит соответствующее изображение кости с указанием количества выпавших сторон. Это сделает ваше приложение более наглядным и улучшит пользовательский интерфейс.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/21cfce4c-4af6-48cd-9264-fb6800bef822)

Вам будет предоставлена ссылка для загрузки изображений dice, и вы добавите их в качестве ресурсов в свое приложение. Чтобы написать код, для которого использовать изображение dice, вы будете использовать when инструкцию в Kotlin.

### Предварительные требования

 * Завершена работа над кодовой таблицей "Создать интерактивное приложение Dice Roller".

 * Возможность написания инструкций потока управления (if / else, when statements).

 * Возможность обновления пользовательского интерфейса приложения на основе пользовательского ввода (изменение MainActivity.kt файла).

 * Возможность добавления прослушивателя кликов в Button.

 * Возможность добавления ресурсов изображений в приложение для Android.

### Чему вы научитесь

 Как обновить ImageView во время работы приложения.

 Как настроить поведение вашего приложения в зависимости от различных условий (с помощью when инструкции).

### Что вы создадите

 *Приложение Dice Roller для Android, в котором есть Button возможность бросать кости и обновлять изображение на экране.

### Что вам нужно

 * На компьютере установлена Android Studio.

 * Подключение к Интернету для загрузки изображений Dice.

## 2. Обновите макет приложения

В этой задаче вы замените TextView в своем макете изображениеImageView, отображающее результат броска кости.

### Откройте приложение Dice Roller

 1. Откройте и запустите приложение Dice Roller из предыдущей codelab в Android Studio. Вы можете использовать код решения или созданный вами код.

Приложение должно выглядеть примерно так.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/d4698f5d-b28e-408b-bf23-6e84855b81d1)

 2. Откройте activity_main.xml (приложение> разрешение> макет > activity_main.xml ). Откроется редактор макетов.

### Удаление текстового представления

 1. В редакторе макетов выберите изображение TextView в дереве компонентов.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/62c450c7-97c3-440c-9799-82419cfe1644)

--------------------------------------------------------------

Совет: По мере добавления новых компонентов пользовательского интерфейса и удаления ограничений вы можете временно обнаружить, что они View перекрывают друг друга, что затрудняет выбор того, что находится сзади. В этом случае вы можете выбрать изображение, View выбрав его вместо этого в дереве компонентов.

--------------------------------------------------------------

 2. Щелкните правой кнопкой мыши и выберите Удалить или нажмите Delete клавишу.

 3. Пока игнорируйте предупреждение на Button. Вы исправите это на следующем шаге.

### Добавьте изображение в макет

 1. Перетащите изображение ImageView из палитры в вид Дизайна, расположив его над Button.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/355319cc-e34d-4ef5-b508-487df6096c87)

 2. В диалоговом окне "Выбор ресурса" выберите аватары в разделе "Образцы данных". Это временное изображение, которое вы будете использовать до тех пор, пока не добавите изображения кубиков в следующем задании.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/9565838a-f67a-420f-9f4b-d102e0179424)

 3. Нажмите OK. Дизайн вашего приложения должен выглядеть следующим образом.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/db3d67a8-60aa-4de1-87ce-4a0028c8d904)

 4. В дереве компонентов вы заметите две ошибки. Button Не ограничено по вертикали, и ImageView не ограничено ни по вертикали, ни по горизонтали.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/ac56b1ad-504b-401f-9166-00a46ed42d5e)

Изображение Button не ограничено по вертикали, потому что вы удалили изображение, TextView под которым оно было изначально расположено. Теперь вам нужно расположить ImageView и Button под ним.

### Расположите изображение и кнопку

Вам нужно расположить их по вертикали ImageView на экране, независимо от того, где они Button расположены.

 1. Добавьте горизонтальные ограничения для ImageView. Соедините левую сторону ImageView с левым краем родительского изображения ConstraintLayout.

 2. Соедините правую сторону ImageView с правым краем родительского изображения. Это позволит расположить изображение по горизонтали ImageView внутри родительского изображения.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/87a2c5f0-548a-47a8-93db-6b6303b0716e)

 3. Добавьте вертикальное ограничение для ImageView, соединяющее верхнюю часть ImageView с верхней частью родительского изображения. Изображение ImageView будет скользить вверх до верхней части ConstraintLayout.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/ed7e6834-7462-41e9-8771-128ee3035643)

 4. Добавьте вертикальное ограничение для Button, соединяющее верхнюю часть Button с нижней ImageView. Button Будет скользить вверх под ImageView.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/94308fa5-9a3a-4866-97c1-e1bf530ca363)

 5. Теперь ImageView снова выберите изображение и добавьте вертикальное ограничение, соединяющее нижнюю часть ImageView с нижней частью родительского изображения. Это позволит расположить изображение ImageView вертикально в ConstraintLayout.

Теперь все предупреждения об ограничениях должны исчезнуть.

После всего этого вид дизайна должен выглядеть следующим образом: ImageView в центре и Button чуть ниже.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/d93e9b90-bbac-49d7-b1ee-96c0f9170a34)

Вы можете заметить предупреждение на ImageView в дереве компонентов, в котором предлагается добавить описание содержимого в ваше ImageView. Пока не беспокойтесь об этом предупреждении, потому что позже в codelab вы будете настраивать описание содержимого ImageView в зависимости от того, какое изображение dice вы показываете. Это изменение будет внесено в код Kotlin.

## 3. Добавляйте изображения в Dice Roller

В этой задаче вы загрузите несколько изображений dice и добавите их в свое приложение.

### Загружайте изображения dice

 1. Откройте этот URL, чтобы загрузить zip-файл с изображениями dice на свой компьютер. Дождитесь завершения загрузки.

 2. Найдите файл на своем компьютере (скорее всего, в папке "Загрузки").

 3. Дважды щелкните zip-файл, чтобы распаковать его. При этом будет создана новая dice_images папка, содержащая 6 файлов изображений dice, в которых отображаются значения dice от 1 до 6.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/7f4df0b8-5e6a-4a59-b118-9293094957c4)

### Добавляйте изображения dice в свое приложение

 1. В Android Studio выберите в меню Вид> Окна инструментов> Диспетчер ресурсов или перейдите на вкладку Менеджер ресурсов слева от окна Проекта.

 2. Нажмите + ниже Resource Manager и выберите Импортировать чертежи. Откроется файловый браузер.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/cf990865-90f8-4be3-b4d4-63580924d404)

 3. Найдите и выберите 6 файлов изображений dice. Вы можете выбрать первый файл, затем, удерживая нажатой клавишу Shift, выбрать другие файлы.

 4. Нажмите Открыть.

 5. Нажмите Далее, а затем Импортировать, чтобы подтвердить, что вы хотите импортировать эти 6 ресурсов.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/39201ade-2441-41a3-b2ca-6189546289c3)

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/9a7263b6-d686-4824-8619-d63eb4745b86)

 6. Если файлы были успешно импортированы, 6 изображений должны появиться в диспетчере ресурсов (приложение> разрешение> возможность рисования) для вашего приложения.

![image](https://github.com/gipnozhard/DiceRoller/assets/71705375/c1288b7b-d7ca-47f9-b8cb-3de4aa0f38c5)

Отличная работа! В следующем задании вы будете использовать эти изображения в своем приложении.

Важно! - Вы сможете ссылаться на эти изображения в своем коде Kotlin, указывая их идентификаторы ресурсов:

 * R.drawable.dice_1
 * R.drawable.dice_2
 * R.drawable.dice_3
 * R.drawable.dice_4
 * R.drawable.dice_5
 * R.drawable.dice_6












